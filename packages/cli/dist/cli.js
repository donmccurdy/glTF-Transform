var e=require("fs"),t=require("minimatch"),o=require("node-gzip"),r=require("@caporal/core"),n=require("@gltf-transform/core"),i=require("@gltf-transform/extensions"),a=require("@gltf-transform/functions"),s=require("cli-table3"),l=require("csv-stringify"),u=require("command-exists"),m=require("ktx-parse"),p=require("meshoptimizer"),c=require("path"),d=require("gltf-validator");function g(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var h=/*#__PURE__*/g(e),f=/*#__PURE__*/g(t),y=/*#__PURE__*/g(s),v=/*#__PURE__*/g(c),b=/*#__PURE__*/g(d);const{spawnSync:x}=require("child_process");function w(e){return e.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")}function T(e,t=2){if(0===e)return"0 Bytes";const o=t<0?0:t,r=Math.floor(Math.log(e)/Math.log(1e3));return parseFloat((e/Math.pow(1e3,r)).toFixed(o))+" "+["Bytes","KB","MB","GB","TB","PB","EB","ZB","YB"][r]}function S(e){return e.match(/.{1,80}(\s|$)/g).map(e=>e.trim()).join("\n")}function E(e){return"\n "+e.toUpperCase()+"\n ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"}function R(e,t){const o=e.getRoot(),r=e.getGraph().listParentEdges(t).filter(e=>e.getParent()!==o).map(e=>e.getName());return Array.from(new Set(r))}function z(e,t){let o=0;for(const r of e.getGraph().listParentEdges(t)){const{channels:t}=r.getAttributes();t?o|=t:r.getParent().propertyType!==n.PropertyType.ROOT&&e.getLogger().warn(`Missing attribute ".channels" on edge, "${r.getName()}".`)}return o}exports.spawnSync=x,exports.commandExistsSync=u.sync;class q{constructor(e,t,o,r){this._io=void 0,this._logger=void 0,this._input=void 0,this._output=void 0,this._io=e,this._logger=t,this._input=o,this._output=r,e.setLogger(t)}static create(e,t,o,r){return new q(e,t,o,r)}transform(){try{const t=this,o=arguments;function e(e){const i=r?e.setLogger(t._logger):e;for(const e of["KHR_draco_mesh_compression","EXT_meshopt_compression"]){const o=i.getRoot().listExtensionsUsed().find(t=>t.extensionName===e);o&&(o.dispose(),t._logger.warn(`Decoded ${e}. Further compression will be lossy.`))}return Promise.resolve(i.transform(...[].slice.call(o))).then(function(){return Promise.resolve(t._io.write(t._output,i)).then(function(){const{lastReadBytes:e,lastWriteBytes:o}=t._io;if(t._input){const r=n.FileUtils.basename(t._input)+"."+n.FileUtils.extension(t._input),i=n.FileUtils.basename(t._output)+"."+n.FileUtils.extension(t._output);t._logger.info(`${r} (${T(e)}) ‚Üí ${i} (${T(o)})`)}else{const e=n.FileUtils.basename(t._output)+"."+n.FileUtils.extension(t._output);t._logger.info(`${e} (${T(o)})`)}})})}const r=t._input;return Promise.resolve(r?Promise.resolve(t._io.read(t._input)).then(e):e((new n.Document).setLogger(t._logger)))}catch(e){return Promise.reject(e)}}}const P=function(e,t,o){try{switch(e){case _.PRETTY:{const e=new y.default({head:t});return e.push(...o),Promise.resolve(e.toString())}case _.CSV:return Promise.resolve(new Promise((e,r)=>{l.stringify([t,...o],(t,o)=>{t?r(t):e(o)})}));case _.MD:{const e=new y.default({head:t,chars:N});return e.push(new Array(o[0].length).fill("---")),e.push(...o),Promise.resolve(e.toString())}}return Promise.resolve()}catch(e){return Promise.reject(e)}},U=function(e,t,o,r){try{const n=r.properties;if(console.log(E(e)),!n.length)return console.log(`No ${e} found.\n`),Promise.resolve();const i=n.map((e,o)=>function(e,t,o){const r={"#":t};for(const t in e){const n=e[t];r[t]=Array.isArray(n)?n.join(", "):t.match(/size/i)&&o!==_.CSV?n>0?T(n):"":"number"==typeof n?o!==_.CSV?w(n):n:"boolean"==typeof n?n?"‚úì":"":n}return r}(e,o,t)),a=Object.keys(i[0]),s=i.map(e=>Object.values(e)),l=t!==_.CSV?function(e,t,o){const r=[];if("meshes"===e){for(let e=0;e<o.length;e++)"size"===o[e]&&(o[e]+="¬π");r.push('¬π size estimates GPU memory required by a mesh, in isolation. If accessors are\n  shared by other mesh primitives, but the meshes themselves are not reused, then\n  the sum of all mesh sizes will overestimate the asset\'s total size. See "dedup".')}if("textures"===e){for(let e=0;e<o.length;e++)"gpuSize"===o[e]&&(o[e]+="¬π");r.push("¬π gpuSize estimates minimum GPU memory allocation. Older devices may require\n  additional memory for GPU compression formats.")}return r}(e,0,a):[];return Promise.resolve(P(t,a,s)).then(function(e){console.log(e),l.length&&console.log("\n"+l.join("\n")),r.warnings&&r.warnings.forEach(e=>o.warn(S(e))),console.log("\n")})}catch(e){return Promise.reject(e)}};var _;!function(e){e.PRETTY="pretty",e.CSV="csv",e.MD="md"}(_||(_={}));const N={top:"","top-mid":"","top-left":"","top-right":"",bottom:"","bottom-mid":"","bottom-left":"","bottom-right":"",left:"|","left-mid":"",mid:"","mid-mid":"",right:"|","right-mid":"",middle:"|"},A={method:"edgebreaker",encodeSpeed:5,decodeSpeed:5,quantizePosition:14,quantizeNormal:10,quantizeColor:8,quantizeTexcoord:12,quantizeGeneric:12,quantizationVolume:"mesh"},M=e=>{const t={...A,...e};return e=>{e.createExtension(i.DracoMeshCompression).setRequired(!0).setEncoderOptions({method:"edgebreaker"===t.method?i.DracoMeshCompression.EncoderMethod.EDGEBREAKER:i.DracoMeshCompression.EncoderMethod.SEQUENTIAL,encodeSpeed:t.encodeSpeed,decodeSpeed:t.decodeSpeed,quantizationBits:{POSITION:t.quantizePosition,NORMAL:t.quantizeNormal,COLOR:t.quantizeColor,TEX_COORD:t.quantizeTexcoord,GENERIC:t.quantizeGeneric},quantizationVolume:t.quantizationVolume})}},C=require("minimatch");function O(){return function(e){try{const t=e.getLogger();let o=0;for(const r of e.getRoot().listTextures()){if("image/ktx2"!==r.getMimeType())continue;const n=r.getImage();if(!n)continue;const i=m.read(n),a=i.dataFormatDescriptor[0],s=R(e,r);if(0===s.length)continue;const l=s.find(e=>C(e,"*{color,emissive}*",{nocase:!0}))?m.KTX2Primaries.SRGB:m.KTX2Primaries.UNSPECIFIED,u=r.getURI()||r.getName();let p=!1;a.colorPrimaries!==l&&(a.colorPrimaries=l,t.info(`ktxfix: Set colorPrimaries=${l} for texture "${u}"`),p=!0),p&&(r.setImage(m.write(i)),o++)}return t.info(`ktxfix: Found and repaired issues in ${o} textures`),t.debug("ktxfix: Complete."),Promise.resolve()}catch(e){return Promise.reject(e)}}}const k=e=>{const{paths:t,io:o}=e;return function(r){try{const i=r.getLogger();return Promise.resolve(Promise.all(t.map(function(e,a){try{i.debug(`Merging ${a+1} / ${t.length}, ${e}`);const s=n.FileUtils.basename(e),l=n.FileUtils.extension(e).toLowerCase();return Promise.resolve(function(){if(!["png","jpg","jpeg","webp","ktx2"].includes(l))return function(){if(["gltf","glb"].includes(l)){const t=r.merge;return Promise.resolve(o.read(e)).then(function(e){t.call(r,e)})}throw new Error(`Unknown file extension: "${l}".`)}();r.createTexture(s).setImage(h.default.readFileSync(e)).setMimeType(n.ImageUtils.extensionToMimeType(l)).setURI(s+"."+l)}())}catch(e){return Promise.reject(e)}}))).then(function(){if(!e.partition){const e=r.getRoot().listBuffers()[0];r.getRoot().listAccessors().forEach(t=>t.setBuffer(e)),r.getRoot().listBuffers().forEach((e,t)=>t>0?e.dispose():null)}i.debug("merge: Complete.")})}catch(e){return Promise.reject(e)}}},I={level:"high"},L=e=>{const t={...I,...e};return function(e){try{return Promise.resolve(e.transform(a.reorder({encoder:p.MeshoptEncoder,target:"size"}),a.quantize({pattern:"medium"===t.level?/.*/:/^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\d+)?$/,quantizePosition:14,quantizeTexcoord:12,quantizeColor:8,quantizeNormal:8}))).then(function(){e.createExtension(i.MeshoptCompression).setRequired(!0).setEncoderOptions({method:"medium"===t.level?i.MeshoptCompression.EncoderMethod.QUANTIZE:i.MeshoptCompression.EncoderMethod.FILTER})})}catch(e){return Promise.reject(e)}}},B=require("fs"),D=require("minimatch"),F=require("semver"),G=require("tmp");G.setGracefulCleanup();const{R:$,G:j}=n.TextureChannel,K={ETC1S:"etc1s",UASTC:"uastc"},X={BOX:"box",TENT:"tent",BELL:"bell",BSPLINE:"b-spline",MITCHELL:"mitchell",LANCZOS3:"lanczos3",LANCZOS4:"lanczos4",LANCZOS6:"lanczos6",LANCZOS12:"lanczos12",BLACKMAN:"blackman",KAISER:"kaiser",GAUSSIAN:"gaussian",CATMULLROM:"catmullrom",QUADRATIC_INTERP:"quadratic_interp",QUADRATIC_APPROX:"quadratic_approx",QUADRATIC_MIX:"quadratic_mix"},V={filter:X.LANCZOS4,filterScale:1,powerOfTwo:!1,slots:"*"},Q={quality:128,compression:1,...V},W={level:2,rdo:0,rdoDictionarySize:32768,rdoBlockScale:10,rdoStdDev:18,rdoMultithreading:!0,zstd:18,...V},Z=function(e){return e={...e.mode===K.ETC1S?Q:W,...e},t=>{const o=t.getLogger();!function(e){if(!exports.commandExistsSync("toktx")&&!process.env.CI)throw new Error('Command "toktx" not found. Please install KTX-Software, from:\n\nhttps://github.com/KhronosGroup/KTX-Software');const{status:t,stdout:o,stderr:r}=exports.spawnSync("toktx",["--version"],{encoding:"utf-8"}),n=(o||r).replace(/toktx\s+/,"").replace(/~\d+/,"").trim();if(0!==t||!F.valid(F.clean(n)))throw new Error('Unable to find "toktx" version. Confirm KTX-Software is installed.');F.lt(F.clean(n),"4.0.0-rc1")?e.warn(`Expected KTX-Software >= v4.0.0-rc1, found ${n}.`):e.debug(`Found KTX-Software ${n}.`)}(o);const r=t.createExtension(i.TextureBasisu).setRequired(!0);let a=0;t.getRoot().listTextures().forEach((r,i)=>{const s=R(t,r),l=z(t,r),u=r.getURI()||r.getName()||`${i+1}/${t.getRoot().listTextures().length}`;if(o.debug(`Texture ${u} (${s.join(", ")})`),"image/ktx2"===r.getMimeType())return void o.debug("‚Ä¢ Skipping, already KTX.");if("image/png"!==r.getMimeType()&&"image/jpeg"!==r.getMimeType())return void o.warn(`‚Ä¢ Skipping, unsupported texture type "${r.getMimeType()}".`);if("*"!==e.slots&&!s.find(t=>D(t,e.slots,{nocase:!0})))return void o.debug(`‚Ä¢ Skipping, excluded by pattern "${e.slots}".`);const m=r.getImage(),p=r.getSize();if(!m||!p)return void o.warn("‚Ä¢ Skipping, unreadable texture.");const c=r.getURI()?n.FileUtils.extension(r.getURI()):n.ImageUtils.mimeTypeToExtension(r.getMimeType()),d=G.tmpNameSync({postfix:"."+c}),g=G.tmpNameSync({postfix:".ktx2"}),h=m.byteLength;B.writeFileSync(d,Buffer.from(m));const f=[...H(s,l,p,o,e),g,d];o.debug(`‚Ä¢ toktx ${f.join(" ")}`);const{status:y,stderr:v}=exports.spawnSync("toktx",f,{stdio:[process.stderr]});if(0!==y)throw o.error(`‚Ä¢ Texture compression failed:\n\n${v.toString()}`),new Error("Texture compression failed");r.setImage(B.readFileSync(g)).setMimeType("image/ktx2"),r.getURI()&&r.setURI(n.FileUtils.basename(r.getURI())+".ktx2"),a++;const b=r.getImage().byteLength;o.debug(`‚Ä¢ ${T(h)} ‚Üí ${T(b)} bytes.`)}),0===a&&o.warn("No textures were found, or none were selected for compression."),t.getRoot().listTextures().find(e=>"image/ktx2"===e.getMimeType())||r.dispose()}};function H(e,t,o,r,n){const i=[];if(i.push("--genmipmap"),n.filter!==V.filter&&i.push("--filter",n.filter),n.filterScale!==V.filterScale&&i.push("--fscale",n.filterScale),n.mode===K.UASTC){const e=n;i.push("--uastc",e.level),e.rdo!==W.rdo&&i.push("--uastc_rdo_l",e.rdo),e.rdoDictionarySize!==W.rdoDictionarySize&&i.push("--uastc_rdo_d",e.rdoDictionarySize),e.rdoBlockScale!==W.rdoBlockScale&&i.push("--uastc_rdo_b",e.rdoBlockScale),e.rdoStdDev!==W.rdoStdDev&&i.push("--uastc_rdo_s",e.rdoStdDev),e.rdoMultithreading||i.push("--uastc_rdo_m"),e.zstd&&e.zstd>0&&i.push("--zcmp",e.zstd)}else{const t=n;i.push("--bcmp"),t.quality!==Q.quality&&i.push("--qlevel",t.quality),t.compression!==Q.compression&&i.push("--clevel",t.compression),t.maxEndpoints&&i.push("--max_endpoints",t.maxEndpoints),t.maxSelectors&&i.push("--max_selectors",t.maxSelectors),t.rdoOff?i.push("--no_endpoint_rdo","--no_selector_rdo"):t.rdoThreshold&&(i.push("--endpoint_rdo_threshold",t.rdoThreshold),i.push("--selector_rdo_threshold",t.rdoThreshold)),e.find(e=>D(e,"*normal*",{nocase:!0}))&&i.push("--normal_map")}let a,s;return e.length&&!e.find(e=>D(e,"*{color,emissive}*",{nocase:!0}))&&i.push("--assign_oetf","linear","--assign_primaries","none"),t===$?i.push("--target_type","R"):t!==j&&t!==($|j)||i.push("--target_type","RG"),n.powerOfTwo?(a=Y(o[0]),s=Y(o[1])):(J(o[0])&&J(o[1])||r.warn(`Texture dimensions ${o[0]}x${o[1]} are NPOT, and may fail in older APIs (including WebGL 1.0) on certain devices.`),a=ee(o[0])?o[0]:te(o[0]),s=ee(o[1])?o[1]:te(o[1])),a===o[0]&&s===o[1]||((a>4096||s>4096)&&r.warn(`Resizing to nearest power of two, ${a}x${s}px. Texture dimensions greater than 4096px may not render on some mobile devices. Resize to a lower resolution before compressing, if needed.`),i.push("--resize",`${a}x${s}`)),i}function J(e){return e<=2||0==(e&e-1)&&0!==e}function Y(e){if(e<=2)return e;if(e<=4)return 4;const t=function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}(e),o=function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}(e);return o-e>e-t?t:o}function ee(e){return e%4==0}function te(e){return e<=2?e:e<=4?4:e%4?e+4-e%4:e}const oe=()=>e=>{const t=e.createExtension(i.MaterialsUnlit).createUnlit();e.getRoot().listMaterials().forEach(e=>{e.setExtension("KHR_materials_unlit",t)})};function re(e,t,o,r){console.log(E(e));const n=o.issues.messages.filter(e=>e.severity===t);if(n.length){const e=new y.default({head:["code","message","severity","pointer"]});e.push(...n.map(e=>Object.values(e))),console.log(e.toString())}else r.info(`No ${e}s found.`);console.log("\n")}let ne;const ie=require("draco3dgltf"),ae=require("mikktspace"),{MeshoptDecoder:se,MeshoptEncoder:le}=require("meshoptimizer"),ue=new Promise(e=>{Promise.all([ie.createDecoderModule(),ie.createEncoderModule(),se.ready,le.ready]).then(([t,o,r])=>{ne=(new n.NodeIO).registerExtensions(i.ALL_EXTENSIONS).registerDependencies({"draco3d.decoder":t,"draco3d.encoder":o,"meshopt.decoder":se,"meshopt.encoder":le}),e()})}),me="Path to read glTF 2.0 (.glb, .gltf) model",pe="Path to write output";r.program.version(require("../package.json").version).description("Commandline interface for the glTF-Transform SDK."),r.program.command("","\n\nüîé INSPECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),r.program.command("inspect","Inspect the contents of the model").help("\nInspect the contents of the model, printing a table with properties and\nstatistics for scenes, meshes, materials, textures, and animations contained\nby the file. This data is useful for understanding how much of a file's size\nis comprised of geometry vs. textures, which extensions are needed when loading\nthe file, and which material properties are being used.\n\nUse --format=csv or --format=md for alternative display formats.\n\t".trim()).argument("<input>",me).option("--format <format>","Table output format",{validator:[_.PRETTY,_.CSV,_.MD],default:_.PRETTY}).action(function({args:e,options:t,logger:o}){try{return ne.setLogger(o),Promise.resolve(ne.readAsJSON(e.input)).then(function(e){return Promise.resolve(function(e,t,o,r){try{const n=e.json.extensionsUsed||[],i=e.json.extensionsRequired||[];return console.log(E("metadata")),Promise.resolve(P(r,["key","value"],[["version",e.json.asset.version],["generator",e.json.asset.generator||""],["extensionsUsed",n.join(", ")||"none"],["extensionsRequired",i.join(", ")||"none"]])).then(function(n){let i;function s(e){const t=a.inspect(i);return Promise.resolve(U("scenes",r,o,t.scenes)).then(function(){return Promise.resolve(U("meshes",r,o,t.meshes)).then(function(){return Promise.resolve(U("materials",r,o,t.materials)).then(function(){return Promise.resolve(U("textures",r,o,t.textures)).then(function(){return Promise.resolve(U("animations",r,o,t.animations)).then(function(){})})})})})}console.log(n+"\n\n");const l=function(o,r){try{var n=Promise.resolve(t.readJSON(e)).then(function(e){i=e})}catch(e){return r(e)}return n&&n.then?n.then(void 0,r):n}(0,function(e){throw o.warn("Unable to parse document."),e});return l&&l.then?l.then(s):s()})}catch(e){return Promise.reject(e)}}(e,ne,o,t.format)).then(function(){})})}catch(e){return Promise.reject(e)}}),r.program.command("validate","Validate the model against the glTF spec").help("\nValidate the model with official glTF validator. The validator detects whether\na file conforms correctly to the glTF specification, and is useful for\ndebugging issues with a model. Validation errors typically suggest a problem\nin the authoring process, and can be reported as bugs on the software used to\nexport the file. Certain lower-priority issues are not technically invalid, but\nmay indicate an unintended situation in the file, like unused data not attached\nto any particular scene.\n\nFor more details about the official validation suite used here, see:\nhttps://github.com/KhronosGroup/glTF-Validator\n\nExample:\n\n  ‚ñ∏ gltf-transform validate input.glb --ignore ACCESSOR_WEIGHTS_NON_NORMALIZED\n\t".trim()).argument("<input>",me).option("--limit <limit>","Limit number of issues to display",{validator:r.program.NUMBER,default:1e7}).option("--ignore <CODE>,<CODE>,...","Issue codes to be ignored",{validator:r.program.ARRAY,default:[]}).action(({args:e,options:t,logger:o})=>{!function(e,t,o){const r=h.default.readFileSync(e);b.default.validateBytes(new Uint8Array(r),{maxIssues:t.limit,ignoredIssues:t.ignore,externalResourceFunction:t=>new Promise((r,n)=>{t=v.default.resolve(v.default.dirname(e),decodeURIComponent(t)),h.default.readFile(t,(e,i)=>{e&&o.warn(`Unable to validate "${t}": ${e.toString()}.`),e?n(e.toString()):r(i)})})}).then(e=>{re("error",0,e,o),re("warning",1,e,o),re("info",2,e,o),re("hint",3,e,o)})}(e.input,t,o)}),r.program.command("","\n\nüì¶ PACKAGE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),r.program.command("copy","Copy the model with minimal changes").alias("cp").help("\nCopy the model from <input> to <output> with minimal changes. Unlike filesystem\n`cp`, this command does parse the file into glTF-Transform's internal\nrepresentation before serializing it to disk again. No other intentional\nchanges are made, so copying a model can be a useful first step to confirm that\nglTF-Transform is reading and writing the model correctly when debugging issues\nin a larger script doing more complex processing of the file. Copying may also\nbe used to ensure consistent data layout across glTF files from different\nexporters, e.g. if your engine always requires interleaved vertex attributes.\n\nWhile vertex data remains byte-for-byte the same before and after copying, and\nscene, node, material, and other properties are also preserved losslessly,\ncertain aspects of data layout may change slightly with this process:\n\n- Vertex attributes within a mesh are interleaved.\n- Accessors are organized into buffer views according to usage.\n- Draco compression is removed to avoid a lossy decompress/compress round trip.\n".trim()).argument("<input>",me).argument("<output>",pe).action(({args:e,logger:t})=>q.create(ne,t,e.input,e.output).transform()),r.program.command("merge","Merge two or more models into one").help("\nMerge two or more models into one, each in a separate Scene. Optionally, the\nbinary data for each model may be kept in a separate buffer with the\n--partition flag.\n\nExample:\n\n  ‚ñ∏ gltf-transform merge a.glb b.glb c.glb output.glb\n\t".trim()).argument("<path...>",`${me}(s). Final path is used to write output.`).option("--partition","Whether to keep separate buffers for each input file. Invalid for GLB output.",{validator:r.program.BOOLEAN,default:!1}).action(({args:e,options:t,logger:o})=>{const r="string"==typeof e.path?e.path.split(","):e.path,n=r.pop();return q.create(ne,o,"",n).transform(k({io:ne,paths:r,partition:!!t.partition}))}),r.program.command("partition","Partition binary data into separate .bin files").help("\nPartition binary data for meshes or animations into separate .bin files. In\nengines that support lazy-loading resources within glTF files, this allows\nrestructuring the data to minimize initial load time, fetching additional\nresources as needed. Partitioning is supported only for .gltf, not .glb, files.\n\t".trim()).argument("<input>",me).argument("<output>",pe).option("--animations","Partition each animation into a separate .bin file",{validator:r.program.BOOLEAN,default:!1}).option("--meshes","Partition each mesh into a separate .bin file",{validator:r.program.BOOLEAN,default:!1}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.partition(t))),r.program.command("dedup","Deduplicate accessors and textures").help("\nDeduplicate accessors, textures, materials, and meshes. Some exporters or\npipeline processing may lead to multiple resources within a file containing\nredundant copies of the same information. This functions scans for these cases\nand merges the duplicates where possible, reducing file size. The process may\nbe very slow on large files with many accessors.\n\nDeduplication early in a pipeline may also help other optimizations, like\ncompression and instancing, to be more effective.\n\t".trim()).argument("<input>",me).argument("<output>",pe).option("--accessors <accessors>","Remove duplicate accessors",{validator:r.program.BOOLEAN,default:!0}).option("--materials <materials>","Remove duplicate materials",{validator:r.program.BOOLEAN,default:!0}).option("--meshes <meshes>","Remove duplicate meshes",{validator:r.program.BOOLEAN,default:!0}).option("--textures <textures>","Remove duplicate textures",{validator:r.program.BOOLEAN,default:!0}).action(({args:e,options:t,logger:o})=>{const r=[];return t.accessors&&r.push(n.PropertyType.ACCESSOR),t.materials&&r.push(n.PropertyType.MATERIAL),t.meshes&&r.push(n.PropertyType.MESH),t.textures&&r.push(n.PropertyType.TEXTURE),q.create(ne,o,e.input,e.output).transform(a.dedup({propertyTypes:r}))}),r.program.command("prune","Remove unreferenced properties from the file").help("\nRemoves properties from the file if they are not referenced by a Scene. Helpful\nwhen cleaning up after complex workflows or a faulty exporter. This function\nmay (conservatively) fail to identify some unused extension properties, such as\nlights, but it will not remove anything that is still in use, even if used by\nan extension. Animations are considered unused if they do not target any nodes\nthat are children of a scene.\n\t".trim()).argument("<input>",me).argument("<output>",pe).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.prune(t))),r.program.command("gzip","Compress the model with lossless gzip").help("\nCompress the model with gzip. Gzip is a general-purpose file compression\ntechnique, not specific to glTF models. On the web, decompression is\nhandled automatically by the web browser, without any intervention from the\nclient application.\n\nWhen the model contains resources that are already effectively compressed, like\nJPEG textures or Draco geometry, gzip is unlikely to add much further benefit\nand can be skipped. Other compression strategies, like Meshopt and quantization,\nwork best when combined with gzip.\n").argument("<input>",me).action(function({args:t,logger:r}){try{return Promise.resolve(e.promises.readFile(t.input)).then(function(n){return Promise.resolve(o.gzip(n)).then(function(o){const i=t.input+".gz",a=T(n.byteLength),s=T(o.byteLength);return Promise.resolve(e.promises.writeFile(i,o)).then(function(){r.info(`Created ${i} (${a} ‚Üí ${s})`)})})})}catch(e){return Promise.reject(e)}}),r.program.command("","\n\nüåç SCENE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),r.program.command("center","Center the scene at the origin, or above/below it").help("\nCenter the scene at the origin, or above/below it. When loading a model into\na larger scene, or into an augmented reality context, it's often best to ensure\nthe model's pivot is centered beneath the object. For objects meant to be\nattached a surface, like a ceiling fan, the pivot may be located above instead.\n\t".trim()).argument("<input>",me).argument("<output>",pe).option("--pivot <pivot>","Method used to determine the scene pivot",{validator:["center","above","below"],default:"center"}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.center({...t}))),r.program.command("instance","Create GPU instances from shared Mesh references").help("\nFor meshes reused by more than one node in a scene, this command creates an\nEXT_mesh_gpu_instancing extension to aid with GPU instancing. In engines that\nsupport the extension, this may allow GPU instancing to be used, reducing draw\ncalls and improving framerate.\n\nEngines may use GPU instancing with or without the presence of this extension,\nand are strongly encouraged to do so. However, particularly when loading a\nmodel at runtime, the extension provides useful context allowing the engine to\nuse this technique efficiently.\n\nInstanced meshes cannot be animated, and must share the same materials. For\nfurther details, see:\n\nhttps://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing.\n\t".trim()).argument("<input>",me).argument("<output>",pe).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.instance({...t}))),r.program.command("","\n\nüïã GEOMETRY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),r.program.command("draco","Compress geometry with Draco").help("\nCompress mesh geometry with the Draco library. This type of compression affects\nonly geometry data ‚Äî animation and textures are not compressed.\n\nCompresses\n- geometry (only triangle meshes)\n\nDocumentation\n- https://gltf-transform.donmccurdy.com/classes/extensions.dracomeshcompression.html\n\nReferences\n- draco: https://github.com/google/draco\n- KHR_draco_mesh_compression: https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/\n".trim()).argument("<input>",me).argument("<output>",pe).option("--method <method>","Compression method.",{validator:["edgebreaker","sequential"],default:"edgebreaker"}).option("--encode-speed <encodeSpeed>","Encoding speed vs. compression level, 1‚Äì10.",{validator:r.program.NUMBER,default:A.encodeSpeed}).option("--decode-speed <decodeSpeed>","Decoding speed vs. compression level, 1‚Äì10.",{validator:r.program.NUMBER,default:A.decodeSpeed}).option("--quantize-position <bits>","Quantization bits for POSITION, 1-16.",{validator:r.program.NUMBER,default:A.quantizePosition}).option("--quantize-normal <bits>","Quantization bits for NORMAL, 1-16.",{validator:r.program.NUMBER,default:A.quantizeNormal}).option("--quantize-color <bits>","Quantization bits for COLOR_*, 1-16.",{validator:r.program.NUMBER,default:A.quantizeColor}).option("--quantize-texcoord <bits>","Quantization bits for TEXCOORD_*, 1-16.",{validator:r.program.NUMBER,default:A.quantizeTexcoord}).option("--quantize-generic <bits>","Quantization bits for other attributes, 1-16.",{validator:r.program.NUMBER,default:A.quantizeGeneric}).option("--quantization-volume <volume>","Bounds for quantization grid.",{validator:["mesh","scene"],default:A.quantizationVolume}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.weld({tolerance:0}),M(t))),r.program.command("meshopt","Compress geometry and animation with Meshopt").help("\nCompress geometry, morph targets, and animation with Meshopt. Meshopt\ncompression decodes very quickly, and is best used in combination with a\nlossless compression method like brotli or gzip.\n\nCompresses\n- geometry (points, lines, triangle meshes)\n- morph targets\n- animation tracks\n\nDocumentation\n- https://gltf-transform.donmccurdy.com/classes/extensions.meshoptcompression.html\n\nReferences\n- meshoptimizer: https://github.com/zeux/meshoptimizer\n- EXT_meshopt_compression: https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Vendor/EXT_meshopt_compression/\n".trim()).argument("<input>",me).argument("<output>",pe).option("--level <level>","Compression level.",{validator:["medium","high"],default:"high"}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(L(t))),r.program.command("quantize","Quantize geometry, reducing precision and memory").help("\nQuantization is a simple type of compression taking 32-bit float vertex\nattributes and storing them as 16-bit or 8-bit integers. A quantization factor\nrestoring the original value (with some error) is applied on the GPU, although\nnode scales and positions may also be changed to account for the quantization.\n\nQuantized vertex attributes require less space, both on disk and on the GPU.\nMost vertex attribute types can be quantized from 8‚Äì16 bits, but are always\nstored in 8- or 16-bit accessors. While a value quantized to 12 bits still\noccupies 16 bits on disk, gzip (or other lossless compression) will be more\neffective on values quantized to lower bit depths. As a result, the default\nbit depths used by this command are generally between 8 and 16 bits.\n\nBit depths for indices and JOINTS_* are determined automatically.\n\nRequires KHR_mesh_quantization support.".trim()).argument("<input>","Path to read glTF 2.0 (.glb, .gltf) input").argument("<output>","Path to write output").option("--pattern <pattern>","Pattern for vertex attributes (case-insensitive glob)",{validator:r.program.STRING,default:"*"}).option("--quantize-position <bits>","Precision for POSITION attributes.",{validator:r.program.NUMBER,default:a.QUANTIZE_DEFAULTS.quantizePosition}).option("--quantize-normal <bits>","Precision for NORMAL and TANGENT attributes.",{validator:r.program.NUMBER,default:a.QUANTIZE_DEFAULTS.quantizeNormal}).option("--quantize-texcoord <bits>","Precision for TEXCOORD_* attributes.",{validator:r.program.NUMBER,default:a.QUANTIZE_DEFAULTS.quantizeTexcoord}).option("--quantize-color <bits>","Precision for COLOR_* attributes.",{validator:r.program.NUMBER,default:a.QUANTIZE_DEFAULTS.quantizeColor}).option("--quantize-weight <bits>","Precision for WEIGHTS_* attributes.",{validator:r.program.NUMBER,default:a.QUANTIZE_DEFAULTS.quantizeWeight}).option("--quantize-generic <bits>","Precision for custom (_*) attributes.",{validator:r.program.NUMBER,default:a.QUANTIZE_DEFAULTS.quantizeGeneric}).option("--quantization-volume <volume>","Bounds for quantization grid.",{validator:["mesh","scene"],default:a.QUANTIZE_DEFAULTS.quantizationVolume}).action(({args:e,options:t,logger:o})=>{const r=f.default.makeRe(String(t.pattern),{nocase:!0});return q.create(ne,o,e.input,e.output).transform(a.quantize({...t,pattern:r}))}),r.program.command("dequantize","Dequantize geometry").help("\nRemoves quantization from an asset. This will increase the size of the asset on\ndisk and in memory, but may be necessary for applications that don't support\nquantization.\n\nRemoves KHR_mesh_quantization, if present.".trim()).argument("<input>","Path to read glTF 2.0 (.glb, .gltf) input").argument("<output>","Path to write output").option("--pattern <pattern>","Pattern for vertex attributes (case-insensitive glob)",{validator:r.program.STRING,default:"!JOINTS_*"}).action(({args:e,options:t,logger:o})=>{const r=f.default.makeRe(String(t.pattern),{nocase:!0});return q.create(ne,o,e.input,e.output).transform(a.dequantize({...t,pattern:r}))}),r.program.command("weld","Index geometry and optionally merge similar vertices").help("\nIndex geometry and optionally merge similar vertices. When merged and indexed,\ndata is shared more efficiently between vertices. File size can be reduced, and\nthe GPU can sometimes use the vertex cache more efficiently. With --tolerance=0,\ngeometry is indexed in place, without merging.\n\t".trim()).argument("<input>",me).argument("<output>",pe).option("--tolerance","Per-attribute tolerance to merge similar vertices",{validator:r.program.NUMBER,default:1e-4}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.weld(t))),r.program.command("unweld","De-index geometry, disconnecting any shared vertices").help('\nDe-index geometry, disconnecting any shared vertices. This tends to increase\nthe file size of the geometry and decrease efficiency, and so is not\nrecommended unless disconnected vertices ("vertex soup") are required for some\nparicular software application.\n\t'.trim()).argument("<input>",me).argument("<output>",pe).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.unweld(t))),r.program.command("tangents","Generate MikkTSpace vertex tangents").help("\nGenerates MikkTSpace vertex tangents.\n\nIn some situations normal maps may appear incorrectly, displaying hard edges\nat seams, or unexpectedly inverted insets and extrusions. The issue is most\ncommonly caused by a mismatch between the software used to bake the normal map\nand the pixel shader or other code used to render it. While this may be a\nfrustration to an artist/designer, it is not always possible for the rendering\nengine to reconstruct the tangent space used by the authoring software.\n\nMost normal map bakers use the MikkTSpace standard (http://www.mikktspace.com/)\nto generate vertex tangents while creating a normal map, and the technique is\nrecommended by the glTF 2.0 specification. Generating vertex tangents with this\ntool may resolve rendering issues related to normal maps in engines that cannot\ncompute MikkTSpace tangents at runtime.\n\t".trim()).argument("<input>",me).argument("<output>",pe).option("--overwrite","Overwrite existing vertex tangents",{validator:r.program.BOOLEAN,default:!1}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.tangents({generateTangents:ae.generateTangents,...t}))),r.program.command("reorder","Optimize vertex data for locality of reference").help("\nOptimize vertex data for locality of reference.\n\nChoose whether the order should be optimal for transmission size (recommended for Web) or for GPU\nrendering performance. When optimizing for transmission size, reordering is expected to be a pre-\nprocessing step before applying Meshopt compression and lossless supercompression (such as gzip or\nbrotli). Reordering will only reduce size when used in combination with other compression methods.\n\nBased on the meshoptimizer library (https://github.com/zeux/meshoptimizer).\n\t".trim()).argument("<input>",me).argument("<output>",pe).option("--target","Whether to optimize for transmission size or GPU performance",{validator:["size","performance"],default:"size"}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.reorder({encoder:le,...t}))),r.program.command("","\n\n‚ú® MATERIAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),r.program.command("metalrough","Convert materials from spec/gloss to metal/rough").help("\nConvert materials from spec/gloss to metal/rough. In general, the metal/rough\nworkflow is better supported, more compact, and more future-proof. All features\nof the spec/gloss workflow can be converted to metal/rough, as long as the\nKHR_materials_specular and KHR_materials_ior extensions are supported. When one\nor both of those extensions are not supported, metallic materials may require\nfurther adjustments after the conversion.\n\nThis conversion rewrites spec/gloss textures, and the resulting textures may\nhave less optimal compression than the original. Ideally, lossless PNG textures\nshould be used as input, and then compressed after this conversion.\n\t".trim()).argument("<input>",me).argument("<output>",pe).action(({args:e,logger:t})=>q.create(ne,t,e.input,e.output).transform(a.metalRough())),r.program.command("unlit","Convert materials from metal/rough to unlit").help("\nConvert materials to an unlit, shadeless model. Unlit materials are not\naffected by scene lighting, and can be rendered very efficiently on less\ncapable mobile devices. If device framerate is high when an object occupies a\nsmall part of the viewport, and low when that object fills the viewport, it's\nlikely that the GPU is fragment shader bound, and a simpler material (such as\nan unlit material) may improve performance.\n\nUnlit materials are also helpful for non-physically-based visual styles.\n\t".trim()).argument("<input>",me).argument("<output>",pe).action(({args:e,logger:t})=>q.create(ne,t,e.input,e.output).transform(oe())),r.program.command("","\n\nüñº  TEXTURE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),r.program.command("resize","Resize PNG or JPEG textures").help("\nResize PNG or JPEG textures with Lanczos3 (sharp) or Lanczos2 (smooth)\nfiltering. Typically Lanczos3 is the best method, but Lanczos2 may be helpful\nto reduce ringing artifacts in some cases.\n\nLimits --width and --height are applied as maximum dimensions for each texture,\npreserving original aspect ratio. Texture dimensions are never increased.\n".trim()).argument("<input>",me).argument("<output>",pe).option("--pattern <pattern>","Pattern (regex) to match textures, by name or URI.",{validator:r.program.STRING}).option("--filter","Resampling filter",{validator:[a.TextureResizeFilter.LANCZOS3,a.TextureResizeFilter.LANCZOS2],default:a.TEXTURE_RESIZE_DEFAULTS.filter}).option("--width <pixels>","Maximum width (px) of output textures.",{validator:r.program.NUMBER,required:!0}).option("--height <pixels>","Maximum height (px) of output textures.",{validator:r.program.NUMBER,required:!0}).action(function({args:e,options:t,logger:o}){try{const r=t.pattern?f.default.makeRe(String(t.pattern),{nocase:!0}):null;return Promise.resolve(q.create(ne,o,e.input,e.output).transform(a.textureResize({size:[t.width,t.height],filter:t.filter,pattern:r})))}catch(e){return Promise.reject(e)}});const ce="\nCompresses textures in the given file to .ktx2 GPU textures using the\n{VARIANT} Basis Universal bitstream. GPU textures offer faster GPU upload\nand less GPU memory consumption than traditional PNG or JPEG textures,\nwhich are fully uncompressed in GPU memory. GPU texture formats require\nmore attention to compression settings to get similar visual results.\n\n{DETAILS}\n\nDocumentation:\nhttps://gltf-transform.donmccurdy.com/extensions.html#khr_texture_basisu\n\nDependencies:\nKTX-Software (https://github.com/KhronosGroup/KTX-Software/)\n";r.program.command("etc1s","KTX + Basis ETC1S texture compression").help(ce.replace("{VARIANT}","ETC1S").replace("{DETAILS}","\nETC1S, one of the two Basis Universal bitstreams, offers lower size and lower\nquality than UASTC. In some cases it may be useful to increase the resolution\nof the texture, to minimize compression artifacts while still retaining an\noverall smaller filesize. Consider using less aggressive compression settings\nfor normal maps than for other texture types: you may want to use UASTC for\nnormal maps and ETC1S for other textures, for example.".trim()),{sectionName:"SUMMARY"}).argument("<input>",me).argument("<output>",pe).option("--slots <slots>","Texture slots to include (glob)",{validator:r.program.STRING,default:"*"}).option("--filter <filter>","Specifies the filter to use when generating mipmaps.",{validator:Object.values(X),default:Q.filter}).option("--filter-scale <fscale>","Specifies the filter scale to use when generating mipmaps.",{validator:r.program.NUMBER,default:Q.filterScale}).option("--compression <clevel>","Compression level, an encoding speed vs. quality tradeoff. Higher values are slower, but give higher quality. Try --quality before experimenting with this option.",{validator:[0,1,2,3,4,5],default:Q.compression}).option("--quality <qlevel>","Quality level. Range is 1 - 255. Lower gives better compression, lower quality, and faster encoding. Higher gives less compression, higher quality, and slower encoding. Quality level determines values of --max_endpoints and --max-selectors, unless those values are explicitly set.",{validator:r.program.NUMBER,default:Q.quality}).option("--max-endpoints <max_endpoints>","Manually set the maximum number of color endpoint clusters from 1-16128.",{validator:r.program.NUMBER}).option("--max-selectors <max_selectors>","Manually set the maximum number of color selector clusters from 1-16128.",{validator:r.program.NUMBER}).option("--power-of-two","Resizes any non-power-of-two textures to the closest power-of-two dimensions, not exceeding 2048x2048px. Required for  compatibility on some older devices and APIs, particularly  WebGL 1.0.",{validator:r.program.BOOLEAN}).option("--rdo-threshold <rdo_threshold>","Set endpoint and selector RDO quality threshold. Lower is higher quality but less quality per output bit (try 1.0-3.0). Overrides --quality.",{validator:r.program.NUMBER}).option("--rdo-off","Disable endpoint and selector RDO (slightly faster, less noisy output, but lower quality per output bit).",{validator:r.program.BOOLEAN}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(Z({mode:K.ETC1S,...t}))),r.program.command("uastc","KTX + Basis UASTC texture compression").help(ce.replace("{VARIANT}","UASTC").replace("{DETAILS}","\nUASTC, one of the two Basis Universal bitstreams, offers higher size and higher\nquality than ETC1S. While it is suitable for all texture types, you may find it\nuseful to apply UASTC only where higher quality is necessary, and apply ETC1S\nfor textures where the quality is sufficient.".trim()),{sectionName:"SUMMARY"}).argument("<input>",me).argument("<output>",pe).option("--slots <slots>","Texture slots to include (glob)",{validator:r.program.STRING,default:"*"}).option("--filter <filter>","Specifies the filter to use when generating mipmaps.",{validator:Object.values(X),default:W.filter}).option("--filter-scale <fscale>","Specifies the filter scale to use when generating mipmaps.",{validator:r.program.NUMBER,default:W.filterScale}).option("--level <level>","Create a texture in high-quality transcodable UASTC format. The optional parameter <level> selects a speed vs quality tradeoff as shown in the following table:\n\nLevel | Speed     | Quality\n‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n0     | Fastest   | 43.45dB\n1     | Faster    | 46.49dB\n2     | Default   | 47.47dB\n3     | Slower    | 48.01dB\n4     | Very slow | 48.24dB",{validator:[0,1,2,3,4],default:W.level}).option("--power-of-two","Resizes any non-power-of-two textures to the closest power-of-two dimensions, not exceeding 2048x2048px. Required for  compatibility on some older devices and APIs, particularly  WebGL 1.0.",{validator:r.program.BOOLEAN}).option("--rdo <uastc_rdo_l>","Enable UASTC RDO post-processing and optionally set UASTC RDO quality scalar (lambda).  Lower values yield higher quality/larger LZ compressed files, higher values yield lower quality/smaller LZ compressed files. A good range to try is [.25, 10]. For normal maps, try [.25, .75]. Full range is [.001, 10.0].",{validator:r.program.NUMBER,default:W.rdo}).option("--rdo-dictionary-size <uastc_rdo_d>","Set UASTC RDO dictionary size in bytes. Default is 32768. Lower values=faster, but give less compression. Possible range is [256, 65536].",{validator:r.program.NUMBER,default:W.rdoDictionarySize}).option("--rdo-block-scale <uastc_rdo_b>","Set UASTC RDO max smooth block error scale. Range is [1.0, 300.0]. Default is 10.0, 1.0 is disabled. Larger values suppress more artifacts (and allocate more bits) on smooth blocks.",{validator:r.program.NUMBER,default:W.rdoBlockScale}).option("--rdo-std-dev <uastc_rdo_s>","Set UASTC RDO max smooth block standard deviation. Range is [.01, 65536.0]. Default is 18.0. Larger values expand the range of blocks considered smooth.",{validator:r.program.NUMBER,default:W.rdoStdDev}).option("--rdo-multithreading <uastc_rdo_m>","Enable RDO multithreading (slightly lower compression, non-deterministic).",{validator:r.program.BOOLEAN,default:W.rdoMultithreading}).option("--zstd <compressionLevel>","Supercompress the data with Zstandard. Compression level range is [1, 22], or 0 is uncompressed. Lower values decode faster but offer less compression. Values above 20 should be used with caution, requiring more memory to decompress:\n\nLevel | Window Size |\n‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî|\n1     | 256 KB      |\n‚Ä¶     | ‚Ä¶           |\n10    | 2 MB        |\n‚Ä¶     | ‚Ä¶           |\n18    | 8 MB        |\n19    | 8 MB        |\n20    | 34 MB       |\n21    | 67 MB       |\n22    | 134 MB      |",{validator:r.program.NUMBER,default:W.zstd}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(Z({mode:K.UASTC,...t}))),r.program.command("ktxfix","Fixes common issues in KTX texture metadata").help("\nCertain KTX texture metadata was written incorrectly in early (pre-release)\nsoftware. In particular, viewers may misinterpret color primaries as sRGB\nincorrectly when a texture exhibits this issue.\n\nThis command determines correct color primaries based on usage in the glTF\nfile, and updates the KTX texture accordingly. The change is lossless, and\naffects only the container metadata.".trim()).argument("<input>",me).argument("<output>",pe).action(({args:e,logger:t})=>q.create(ne,t,e.input,e.output).transform(O())),r.program.command("","\n\n‚èØ  ANIMATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"),r.program.command("resample","Resample animations, losslessly deduplicating keyframes").help('\nResample animations, losslessly deduplicating keyframes. Exporters sometimes\nneed to "bake" animations, writing data for 20-30 frames per second, in order\nto correctly represent IK constraints and other animation techniques. These\nadditional keyframes are often redundant ‚Äî particularly with morph targets ‚Äî\nas engines can interpolate animation at 60‚Äì120 FPS even with sparse keyframes.\n\nThe resampling process removes redundant keyframes from animations using STEP\nand LINEAR interpolation. Resampling is nearly lossless, with configurable\n--tolerance, and should have no visible effect on animation playback.\n\t'.trim()).argument("<input>",me).argument("<output>",pe).option("--tolerance","Per-value tolerance to merge similar keyframes",{validator:r.program.NUMBER,default:1e-4}).action(({args:e,options:t,logger:o})=>q.create(ne,o,e.input,e.output).transform(a.resample(t))),r.program.command("sequence","Animate node visibilities as a flipboard sequence").help("\nAnimate node visibilities as a flipboard sequence. An example workflow would\nbe to create a .glb containing one geometry for each frame of a complex\nanimation that can't be represented as TRS, skinning, or morph targets. The\nsequence function generates a new animation, playing back each mesh matching\nthe given pattern, at a specific framerate. Displaying a sequence of textures\nis also supported, but note that texture memory usage may be quite high and\nso this workflow is not a replacement for video playback.\n\t".trim()).argument("<input>",me).argument("<output>",pe).option("--name <name>","Name of new animation",{validator:r.program.STRING,default:""}).option("--pattern <pattern>","Pattern for node names (case-insensitive glob)",{validator:r.program.STRING,required:!0}).option("--fps <fps>","FPS (frames / second)",{validator:r.program.NUMBER,default:10}).option("--sort <sort>","Order sequence by node name",{validator:r.program.BOOLEAN,default:!0}).action(({args:e,options:t,logger:o})=>{const r=f.default.makeRe(String(t.pattern),{nocase:!0});return q.create(ne,o,e.input,e.output).transform(a.sequence({...t,pattern:r}))}),r.program.option("--vertex-layout <layout>","Vertex layout method",{global:!0,default:n.VertexLayout.INTERLEAVED,validator:[n.VertexLayout.INTERLEAVED,n.VertexLayout.SEPARATE],action:({options:e})=>{ne.setVertexLayout(e.vertexLayout)}}),r.program.disableGlobalOption("--quiet"),r.program.disableGlobalOption("--no-color"),Object.defineProperty(exports,"program",{enumerable:!0,get:function(){return r.program}}),exports.DRACO_DEFAULTS=A,exports.ETC1S_DEFAULTS=Q,exports.Filter=X,exports.MESHOPT_DEFAULTS=I,exports.Mode=K,exports.Session=q,exports.UASTC_DEFAULTS=W,exports.draco=M,exports.formatBytes=T,exports.formatHeader=E,exports.formatLong=w,exports.formatParagraph=S,exports.getTextureChannels=z,exports.getTextureSlots=R,exports.ktxfix=O,exports.merge=k,exports.meshopt=L,exports.mockCommandExistsSync=function(e){exports.commandExistsSync=e},exports.mockSpawnSync=function(e){exports.spawnSync=e},exports.programReady=ue,exports.toktx=Z,exports.unlit=oe;
//# sourceMappingURL=cli.js.map
