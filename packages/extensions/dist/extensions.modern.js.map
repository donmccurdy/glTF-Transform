{"version":3,"file":"extensions.modern.js","sources":["../src/ext-mesh-gpu-instancing/instanced-mesh.ts","../src/constants.ts","../src/ext-mesh-gpu-instancing/mesh-gpu-instancing.ts","../src/ext-meshopt-compression/constants.ts","../src/ext-meshopt-compression/encoder.ts","../src/ext-meshopt-compression/meshopt-compression.ts","../src/ext-meshopt-compression/decoder.ts","../src/ext-texture-webp/texture-webp.ts","../src/khr-draco-mesh-compression/decoder.ts","../src/khr-draco-mesh-compression/encoder.ts","../src/khr-draco-mesh-compression/draco-mesh-compression.ts","../src/khr-lights-punctual/light.ts","../src/khr-lights-punctual/lights-punctual.ts","../src/khr-materials-clearcoat/clearcoat.ts","../src/khr-materials-clearcoat/materials-clearcoat.ts","../src/khr-materials-emissive-strength/emissive-strength.ts","../src/khr-materials-emissive-strength/materials-emissive-strength.ts","../src/khr-materials-ior/ior.ts","../src/khr-materials-ior/materials-ior.ts","../src/khr-materials-pbr-specular-glossiness/pbr-specular-glossiness.ts","../src/khr-materials-pbr-specular-glossiness/materials-pbr-specular-glossiness.ts","../src/khr-materials-sheen/sheen.ts","../src/khr-materials-sheen/materials-sheen.ts","../src/khr-materials-specular/specular.ts","../src/khr-materials-specular/materials-specular.ts","../src/khr-materials-transmission/transmission.ts","../src/khr-materials-transmission/materials-transmission.ts","../src/khr-materials-unlit/unlit.ts","../src/khr-materials-unlit/materials-unlit.ts","../src/khr-materials-variants/mapping.ts","../src/khr-materials-variants/mapping-list.ts","../src/khr-materials-variants/variant.ts","../src/khr-materials-variants/materials-variants.ts","../src/khr-materials-volume/volume.ts","../src/khr-materials-volume/materials-volume.ts","../src/khr-mesh-quantization/mesh-quantization.ts","../src/khr-texture-basisu/texture-basisu.ts","../src/khr-texture-transform/transform.ts","../src/khr-texture-transform/texture-transform.ts","../src/extensions.ts"],"sourcesContent":["import { Accessor, ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\n\ninterface IInstancedMesh extends IProperty {\n\tattributes: { [key: string]: Accessor };\n}\n\n// See BufferViewUsage in `writer-context.ts`.\nexport const INSTANCE_ATTRIBUTE = 'INSTANCE_ATTRIBUTE';\n\n/**\n * # InstancedMesh\n *\n * Defines GPU instances of a {@link Mesh} under one {@link Node}. See {@link MeshGPUInstancing}.\n */\nexport class InstancedMesh extends ExtensionProperty<IInstancedMesh> {\n\tpublic static EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;\n\tpublic declare extensionName: typeof EXT_MESH_GPU_INSTANCING;\n\tpublic declare propertyType: 'InstancedMesh';\n\tpublic declare parentTypes: [PropertyType.NODE];\n\n\tprotected init(): void {\n\t\tthis.extensionName = EXT_MESH_GPU_INSTANCING;\n\t\tthis.propertyType = 'InstancedMesh';\n\t\tthis.parentTypes = [PropertyType.NODE];\n\t}\n\n\tprotected getDefaults(): Nullable<IInstancedMesh> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { attributes: {} });\n\t}\n\n\t/** Returns an instance attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets an instance attribute to an {@link Accessor}. All attributes must have the same\n\t * instance count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: INSTANCE_ATTRIBUTE });\n\t}\n\n\t/**\n\t * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order\n\t * will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all instance attribute semantics associated with the primitive. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n}\n","export const EXT_MESH_GPU_INSTANCING = 'EXT_mesh_gpu_instancing';\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const EXT_TEXTURE_WEBP = 'EXT_texture_webp';\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nexport const KHR_MATERIALS_CLEARCOAT = 'KHR_materials_clearcoat';\nexport const KHR_MATERIALS_EMISSIVE_STRENGTH = 'KHR_materials_emissive_strength';\nexport const KHR_MATERIALS_IOR = 'KHR_materials_ior';\nexport const KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = 'KHR_materials_pbrSpecularGlossiness';\nexport const KHR_MATERIALS_SHEEN = 'KHR_materials_sheen';\nexport const KHR_MATERIALS_SPECULAR = 'KHR_materials_specular';\nexport const KHR_MATERIALS_TRANSMISSION = 'KHR_materials_transmission';\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport const KHR_MATERIALS_VOLUME = 'KHR_materials_volume';\nexport const KHR_MATERIALS_VARIANTS = 'KHR_materials_variants';\nexport const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\nexport const KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\nexport const KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\n","import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { EXT_MESH_GPU_INSTANCING } from '../constants';\nimport { InstancedMesh, INSTANCE_ATTRIBUTE } from './instanced-mesh';\n\nconst NAME = EXT_MESH_GPU_INSTANCING;\n\ninterface InstancedMeshDef {\n\tattributes: {\n\t\t[name: string]: number;\n\t};\n}\n\n/**\n * # MeshGPUInstancing\n *\n * [`EXT_mesh_gpu_instancing`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/)\n * prepares mesh data for efficient GPU instancing.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * GPU instancing allows engines to render many copies of a single mesh at once using a small number\n * of draw calls. Instancing is particularly useful for things like trees, grass, road signs, etc.\n * Keep in mind that predefined batches, as used in this extension, may prevent frustum culling\n * within a batch. Dividing batches into collocated cells may be preferable to using a single large\n * batch.\n *\n * > _**NOTICE:** While this extension stores mesh data optimized for GPU instancing, it\n * > is important to note that (1) GPU instancing and other optimizations are possible — and\n * > encouraged — even without this extension, and (2) other common meanings of the term\n * > \"instancing\" exist, distinct from this extension. See\n * > [Appendix: Motivation and Purpose](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing#appendix-motivation-and-purpose)\n * > of the `EXT_mesh_gpu_instancing` specification._\n *\n * Properties:\n * - {@link InstancedMesh}\n *\n * ### Example\n *\n * The `MeshGPUInstancing` class provides a single {@link ExtensionProperty} type, `InstancedMesh`,\n * which may be attached to any {@link Node} instance. For example:\n *\n * ```typescript\n * import { MeshGPUInstancing } from '@gltf-transform/extensions';\n *\n * // Create standard mesh, node, and scene hierarchy.\n * // ...\n *\n * // Assign positions for each instance.\n * const batchPositions = doc.createAccessor('instance_positions')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0,\n * \t\t1, 0, 0,\n * \t\t2, 0, 0,\n * \t]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(buffer);\n *\n * // Assign IDs for each instance.\n * const batchIDs = doc.createAccessor('instance_ids')\n * \t.setArray(new Uint8Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR)\n * \t.setBuffer(buffer);\n *\n * // Create an Extension attached to the Document.\n * const batchExtension = document.createExtension(MeshGPUInstancing)\n * \t.setRequired(true);\n * const batch = batchExtension.createInstancedMesh()\n * \t.setAttribute('TRANSLATION', batchPositions)\n * \t.setAttribute('_ID', batchIDs);\n *\n * node\n * \t.setMesh(mesh)\n * \t.setExtension('EXT_mesh_gpu_instancing', batch);\n * ```\n *\n * Standard instance attributes are `TRANSLATION`, `ROTATION`, and `SCALE`, and support the accessor\n * types allowed by the extension specification. Custom instance attributes are allowed, and should\n * be prefixed with an underscore (`_*`).\n */\nexport class MeshGPUInstancing extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly provideTypes = [PropertyType.NODE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new InstancedMesh property for use on a {@link Node}. */\n\tpublic createInstancedMesh(): InstancedMesh {\n\t\treturn new InstancedMesh(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst nodeDefs = jsonDoc.json.nodes || [];\n\t\tnodeDefs.forEach((nodeDef, nodeIndex) => {\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\n\n\t\t\tconst instancedMeshDef = nodeDef.extensions[NAME] as InstancedMeshDef;\n\t\t\tconst instancedMesh = this.createInstancedMesh();\n\n\t\t\tfor (const semantic in instancedMeshDef.attributes) {\n\t\t\t\tinstancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);\n\t\t\t}\n\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, instancedMesh);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\t// Set usage for instance attribute accessors, so they are stored in separate buffer\n\t\t// views grouped by parent reference.\n\t\tcontext.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);\n\t\tfor (const prop of this.properties) {\n\t\t\tfor (const attribute of (prop as InstancedMesh).listAttributes()) {\n\t\t\t\tcontext.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listNodes()\n\t\t\t.forEach((node) => {\n\t\t\t\tconst instancedMesh = node.getExtension<InstancedMesh>(NAME);\n\t\t\t\tif (instancedMesh) {\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\n\n\t\t\t\t\tconst instancedMeshDef = { attributes: {} } as InstancedMeshDef;\n\n\t\t\t\t\tinstancedMesh.listSemantics().forEach((semantic) => {\n\t\t\t\t\t\tconst attribute = instancedMesh.getAttribute(semantic)!;\n\t\t\t\t\t\tinstancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute)!;\n\t\t\t\t\t});\n\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\t\t\tnodeDef.extensions[NAME] = instancedMeshDef;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { GLTF, TypedArray } from '@gltf-transform/core';\n\nexport enum EncoderMethod {\n\tQUANTIZE = 'quantize',\n\tFILTER = 'filter',\n}\n\nexport interface MeshoptBufferExtension {\n\tfallback?: boolean;\n}\n\nexport enum MeshoptMode {\n\tATTRIBUTES = 'ATTRIBUTES',\n\tTRIANGLES = 'TRIANGLES',\n\tINDICES = 'INDICES',\n}\n\nexport enum MeshoptFilter {\n\tNONE = 'NONE',\n\tOCTAHEDRAL = 'OCTAHEDRAL',\n\tQUATERNION = 'QUATERNION',\n\tEXPONENTIAL = 'EXPONENTIAL',\n}\n\nexport interface MeshoptBufferViewExtension {\n\tbuffer: number;\n\tbyteOffset: number;\n\tbyteLength: number;\n\tbyteStride: number;\n\tcount: number;\n\tmode: MeshoptMode;\n\tfilter?: MeshoptFilter;\n}\n\n/**\n * When using filters, the accessor definition written to the file will not necessarily have the\n * same properties as the input accessor. For example, octahedral encoding requires int8 or int16\n * output, so float32 input must be ignored.\n */\nexport interface PreparedAccessor {\n\tarray: TypedArray;\n\tbyteStride: number;\n\tnormalized: boolean;\n\tcomponentType: GLTF.AccessorComponentType;\n\tmin?: number[];\n\tmax?: number[];\n}\n","import { PreparedAccessor, MeshoptFilter, MeshoptMode } from './constants';\nimport {\n\tAccessor,\n\tAnimationChannel,\n\tAnimationSampler,\n\tBufferUtils,\n\tDocument,\n\tGLTF,\n\tMathUtils,\n\tPrimitive,\n\tRoot,\n\tTypedArray,\n\tTypedArrayConstructor,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst { BYTE, SHORT, FLOAT } = Accessor.ComponentType;\nconst { normalize, denormalize } = MathUtils;\n\n/** Pre-processes array with required filters or padding. */\nexport function prepareAccessor(\n\taccessor: Accessor,\n\tencoder: typeof MeshoptEncoder,\n\tmode: MeshoptMode,\n\tfilterOptions: { filter: MeshoptFilter; bits?: number }\n): PreparedAccessor {\n\tconst { filter, bits } = filterOptions as { filter: MeshoptFilter; bits: number };\n\tconst result: PreparedAccessor = {\n\t\tarray: accessor.getArray()!,\n\t\tbyteStride: accessor.getElementSize() * accessor.getComponentSize(),\n\t\tcomponentType: accessor.getComponentType(),\n\t\tnormalized: accessor.getNormalized(),\n\t};\n\n\tif (mode !== MeshoptMode.ATTRIBUTES) return result;\n\n\tif (filter !== MeshoptFilter.NONE) {\n\t\tlet array = accessor.getNormalized() ? denormalizeArray(accessor) : new Float32Array(result.array);\n\n\t\tswitch (filter) {\n\t\t\tcase MeshoptFilter.EXPONENTIAL: // → K single-precision floating point values.\n\t\t\t\tresult.byteStride = accessor.getElementSize() * 4;\n\t\t\t\tresult.componentType = FLOAT;\n\t\t\t\tresult.normalized = false;\n\t\t\t\tresult.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tcase MeshoptFilter.OCTAHEDRAL: // → four 8- or 16-bit normalized values.\n\t\t\t\tresult.byteStride = bits > 8 ? 8 : 4;\n\t\t\t\tresult.componentType = bits > 8 ? SHORT : BYTE;\n\t\t\t\tresult.normalized = true;\n\t\t\t\tarray = accessor.getElementSize() === 3 ? padNormals(array) : array;\n\t\t\t\tresult.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tcase MeshoptFilter.QUATERNION: // → four 16-bit normalized values.\n\t\t\t\tresult.byteStride = 8;\n\t\t\t\tresult.componentType = SHORT;\n\t\t\t\tresult.normalized = true;\n\t\t\t\tresult.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid filter.');\n\t\t}\n\n\t\tresult.min = accessor.getMin([]);\n\t\tresult.max = accessor.getMax([]);\n\t\tif (accessor.getNormalized()) {\n\t\t\tresult.min = result.min.map((v) => denormalize(v, accessor.getComponentType()));\n\t\t\tresult.max = result.max.map((v) => denormalize(v, accessor.getComponentType()));\n\t\t}\n\t\tif (result.normalized) {\n\t\t\tresult.min = result.min.map((v) => normalize(v, result.componentType));\n\t\t\tresult.max = result.max.map((v) => normalize(v, result.componentType));\n\t\t}\n\t} else if (result.byteStride % 4) {\n\t\tresult.array = padArrayElements(result.array, accessor.getElementSize());\n\t\tresult.byteStride = result.array.byteLength / accessor.getCount();\n\t}\n\n\treturn result;\n}\n\nfunction denormalizeArray(attribute: Accessor): Float32Array {\n\tconst componentType = attribute.getComponentType();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = new Float32Array(srcArray.length);\n\tfor (let i = 0; i < srcArray.length; i++) {\n\t\tdstArray[i] = denormalize(srcArray[i], componentType);\n\t}\n\treturn dstArray;\n}\n\n/** Pads array to 4 byte alignment, required for Meshopt ATTRIBUTE buffer views. */\nexport function padArrayElements<T extends TypedArray>(srcArray: T, elementSize: number): T {\n\tconst byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);\n\tconst elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;\n\tconst elementCount = srcArray.length / elementSize;\n\n\tconst dstArray = new (srcArray.constructor as TypedArrayConstructor)(elementCount * elementStride) as T;\n\n\tfor (let i = 0; i * elementSize < srcArray.length; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[i * elementStride + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn dstArray;\n}\n\n/** Pad normals with a .w component for octahedral encoding. */\nfunction padNormals(srcArray: Float32Array): Float32Array {\n\tconst dstArray = new Float32Array((srcArray.length * 4) / 3);\n\tfor (let i = 0, il = srcArray.length / 3; i < il; i++) {\n\t\tdstArray[i * 4] = srcArray[i * 3];\n\t\tdstArray[i * 4 + 1] = srcArray[i * 3 + 1];\n\t\tdstArray[i * 4 + 2] = srcArray[i * 3 + 2];\n\t}\n\treturn dstArray;\n}\n\nexport function getMeshoptMode(accessor: Accessor, usage: string): MeshoptMode {\n\tif (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n\t\tconst isTriangles = accessor.listParents().some((parent) => {\n\t\t\treturn parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;\n\t\t});\n\t\treturn isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;\n\t}\n\n\treturn MeshoptMode.ATTRIBUTES;\n}\n\nexport function getMeshoptFilter(accessor: Accessor, doc: Document): { filter: MeshoptFilter; bits?: number } {\n\tconst refs = doc\n\t\t.getGraph()\n\t\t.listParentEdges(accessor)\n\t\t.filter((edge) => !(edge.getParent() instanceof Root));\n\n\tfor (const ref of refs) {\n\t\tconst refName = ref.getName();\n\t\tconst refKey = (ref.getAttributes().key || '') as string;\n\n\t\t// Indices.\n\t\tif (refName === 'indices') return { filter: MeshoptFilter.NONE };\n\n\t\t// Attributes.\n\t\t//\n\t\t// NOTES:\n\t\t// - Vertex attributes should be filtered IFF they are _not_ quantized in\n\t\t//   'packages/cli/src/transforms/meshopt.ts'.\n\t\t// - POSITION and TEXCOORD_0 could use exponential filtering, but this produces broken\n\t\t//   output in some cases (e.g. Matilda.glb), for unknown reasons. gltfpack uses manual\n\t\t//   quantization for these attributes.\n\t\tif (refName === 'attributes') {\n\t\t\tif (refKey === 'POSITION') return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey === 'TEXCOORD_0') return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey === 'NORMAL') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\n\t\t\tif (refKey === 'TANGENT') return { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\n\t\t\tif (refKey.startsWith('JOINTS_')) return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey.startsWith('WEIGHTS_')) return { filter: MeshoptFilter.NONE };\n\t\t}\n\n\t\t// Animation.\n\t\tif (refName === 'output') {\n\t\t\tconst targetPath = getTargetPath(accessor);\n\t\t\tif (targetPath === 'rotation') return { filter: MeshoptFilter.QUATERNION, bits: 16 };\n\t\t\tif (targetPath === 'translation') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\t\tif (targetPath === 'scale') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\t\treturn { filter: MeshoptFilter.NONE };\n\t\t}\n\t\tif (refName === 'input') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\tif (refName === 'inverseBindMatrices') return { filter: MeshoptFilter.NONE };\n\t}\n\n\treturn { filter: MeshoptFilter.NONE };\n}\n\nexport function getTargetPath(accessor: Accessor): GLTF.AnimationChannelTargetPath | null {\n\tfor (const sampler of accessor.listParents()) {\n\t\tif (!(sampler instanceof AnimationSampler)) continue;\n\t\tfor (const channel of sampler.listParents()) {\n\t\t\tif (!(channel instanceof AnimationChannel)) continue;\n\t\t\treturn channel.getTargetPath();\n\t\t}\n\t}\n\treturn null;\n}\n","import {\n\tAccessor,\n\tBuffer,\n\tBufferUtils,\n\tExtension,\n\tGLB_BUFFER,\n\tGLTF,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { EncoderMethod, MeshoptBufferViewExtension, MeshoptFilter } from './constants';\nimport { EXT_MESHOPT_COMPRESSION } from '../constants';\nimport { getMeshoptFilter, getMeshoptMode, getTargetPath, prepareAccessor } from './encoder';\nimport { isFallbackBuffer } from './decoder';\nimport type { MeshoptEncoder, MeshoptDecoder } from 'meshoptimizer';\n\nconst NAME = EXT_MESHOPT_COMPRESSION;\n\ninterface EncoderOptions {\n\tmethod?: EncoderMethod;\n}\n\nconst DEFAULT_ENCODER_OPTIONS: Required<EncoderOptions> = {\n\tmethod: EncoderMethod.QUANTIZE,\n};\n\ntype MeshoptBufferView = { extensions: { [NAME]: MeshoptBufferViewExtension } };\ntype EncodedBufferView = GLTF.IBufferView & MeshoptBufferView;\n\n/**\n * # MeshoptCompression\n *\n * [`EXT_meshopt_compression`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Vendor/EXT_meshopt_compression/)\n * provides compression and fast decoding for geometry, morph targets, and animations.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * Meshopt compression (based on the [meshoptimizer](https://github.com/zeux/meshoptimizer)\n * library) offers a lightweight decoder with very fast runtime decompression, and is\n * appropriate for models of any size. Meshopt can reduce the transmission sizes of geometry,\n * morph targets, animation, and other numeric data stored in buffer views. When textures are\n * large, other complementary compression methods should be used as well.\n *\n * For the full benefits of meshopt compression, **apply gzip, brotli, or another lossless\n * compression method** to the resulting .glb, .gltf, or .bin files. Meshopt specifically\n * pre-optimizes assets for this purpose — without this secondary compression, the size\n * reduction is considerably less.\n *\n * Be aware that decompression happens before uploading to the GPU. While Meshopt decoding is\n * considerably faster than Draco decoding, neither compression method will improve runtime\n * performance directly. To improve framerate, you'll need to simplify the geometry by reducing\n * vertex count or draw calls — not just compress it. Finally, be aware that Meshopt compression is\n * lossy: repeatedly compressing and decompressing a model in a pipeline will lose precision, so\n * compression should generally be the last stage of an art workflow, and uncompressed original\n * files should be kept.\n *\n * The meshoptimizer library ([github](https://github.com/zeux/meshoptimizer/tree/master/js),\n * [npm](https://www.npmjs.com/package/meshoptimizer)) is a required dependency for reading or\n * writing files, and must be provided by the application. Compression may alternatively be applied\n * with the [gltfpack](https://github.com/zeux/meshoptimizer/tree/master/gltf) tool.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { MeshoptCompression } from '@gltf-transform/extensions';\n * import { MeshoptDecoder } from 'meshoptimizer';\n *\n * await MeshoptDecoder.ready;\n *\n * const io = new NodeIO()\n *\t.registerExtensions([MeshoptCompression])\n *\t.registerDependencies({\n *\t\t'meshopt.decoder': MeshoptDecoder,\n *\t\t'meshopt.encoder': MeshoptEncoder,\n *\t});\n *\n * // Read and decode.\n * const document = await io.read('compressed.glb');\n *\n * // Write and encode. (Medium, -c)\n * await document.transform(reorder(), quantize());\n * document.createExtension(MeshoptCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.QUANTIZE });\n * await io.write('compressed-medium.glb', document);\n *\n * // Write and encode. (High, -cc)\n * await document.transform(\n * \treorder(),\n * \tquantize({pattern: /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/}),\n * );\n * document.createExtension(MeshoptCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({ method: MeshoptCompression.EncoderMethod.FILTER });\n * await io.write('compressed-high.glb', document);\n * ```\n */\nexport class MeshoptCompression extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];\n\t/** @hidden */\n\tpublic readonly readDependencies = ['meshopt.decoder'];\n\t/** @hidden */\n\tpublic readonly writeDependencies = ['meshopt.encoder'];\n\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic static readonly EncoderMethod = EncoderMethod;\n\n\tprivate _decoder: typeof MeshoptDecoder | null = null;\n\tprivate _decoderFallbackBufferMap = new Map<Buffer, Buffer>();\n\tprivate _encoder: typeof MeshoptEncoder | null = null;\n\tprivate _encoderOptions: Required<EncoderOptions> = DEFAULT_ENCODER_OPTIONS;\n\tprivate _encoderFallbackBuffer: Buffer | null = null;\n\tprivate _encoderBufferViews: { [key: string]: EncodedBufferView } = {};\n\tprivate _encoderBufferViewData: { [key: string]: Uint8Array[] } = {};\n\tprivate _encoderBufferViewAccessors: { [key: string]: GLTF.IAccessor[] } = {};\n\n\t/** @hidden */\n\tpublic install(key: string, dependency: unknown): this {\n\t\tif (key === 'meshopt.decoder') {\n\t\t\tthis._decoder = dependency as typeof MeshoptDecoder;\n\t\t}\n\t\tif (key === 'meshopt.encoder') {\n\t\t\tthis._encoder = dependency as typeof MeshoptEncoder;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configures Meshopt options for quality/compression tuning. The two methods rely on different\n\t * pre-processing before compression, and should be compared on the basis of (a) quality/loss\n\t * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.\n\t *\n\t * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified\n\t * \tprecision) before applying lossless Meshopt compression. Offers a considerable compression\n\t * \tratio with or without further supercompression. Equivalent to `gltfpack -c`.\n\t * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless\n\t *\tMeshopt compression. While output may initially be larger than with the QUANTIZE method,\n\t *\tthis method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to\n\t * \t`gltfpack -cc`.\n\t *\n\t * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or\n\t * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast\n\t * with both methods.\n\t *\n\t * Example:\n\t *\n\t * ```ts\n\t * doc.createExtension(MeshoptCompression)\n\t * \t.setRequired(true)\n\t * \t.setEncoderOptions({\n\t * \t\tmethod: MeshoptCompression.EncoderMethod.QUANTIZE\n\t * \t});\n\t * ```\n\t */\n\tpublic setEncoderOptions(options: EncoderOptions): this {\n\t\tthis._encoderOptions = { ...DEFAULT_ENCODER_OPTIONS, ...options };\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Decoding.\n\t */\n\n\t/** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */\n\tpublic preread(context: ReaderContext, propertyType: PropertyType): this {\n\t\tif (!this._decoder) {\n\t\t\tif (!this.isRequired()) return this;\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"meshopt.decoder\".`);\n\t\t}\n\t\tif (!this._decoder.supported) {\n\t\t\tif (!this.isRequired()) return this;\n\t\t\tthrow new Error(`[${NAME}]: Missing WASM support.`);\n\t\t}\n\n\t\tif (propertyType === PropertyType.BUFFER) {\n\t\t\tthis._prereadBuffers(context);\n\t\t} else if (propertyType === PropertyType.PRIMITIVE) {\n\t\t\tthis._prereadPrimitives(context);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @internal Decode buffer views. */\n\tprivate _prereadBuffers(context: ReaderContext): void {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\n\t\tviewDefs.forEach((viewDef, index) => {\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\n\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\n\t\t\tconst byteOffset = meshoptDef.byteOffset || 0;\n\t\t\tconst byteLength = meshoptDef.byteLength || 0;\n\t\t\tconst count = meshoptDef.count;\n\t\t\tconst stride = meshoptDef.byteStride;\n\t\t\tconst result = new Uint8Array(count * stride);\n\n\t\t\tconst bufferDef = jsonDoc.json.buffers![viewDef.buffer];\n\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\n\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\tconst source = BufferUtils.toView(resource, byteOffset, byteLength);\n\n\t\t\tthis._decoder!.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);\n\n\t\t\tcontext.bufferViews[index] = result;\n\t\t});\n\t}\n\n\t/**\n\t * Mark fallback buffers and replacements.\n\t *\n\t * Note: Alignment with primitives is arbitrary; this just needs to happen\n\t * after Buffers have been parsed.\n\t * @internal\n\t */\n\tprivate _prereadPrimitives(context: ReaderContext): void {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\n\n\t\t//\n\t\tviewDefs.forEach((viewDef) => {\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\n\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\n\n\t\t\tconst buffer = context.buffers[meshoptDef.buffer];\n\t\t\tconst fallbackBuffer = context.buffers[viewDef.buffer];\n\t\t\tconst fallbackBufferDef = jsonDoc.json.buffers![viewDef.buffer];\n\t\t\tif (isFallbackBuffer(fallbackBufferDef)) {\n\t\t\t\tthis._decoderFallbackBufferMap.set(fallbackBuffer, buffer);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @hidden Removes Fallback buffers, if extension is required. */\n\tpublic read(_context: ReaderContext): this {\n\t\tif (!this.isRequired()) return this;\n\n\t\t// Replace fallback buffers.\n\t\tfor (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {\n\t\t\tfor (const parent of fallbackBuffer.listParents()) {\n\t\t\t\tif (parent instanceof Accessor) {\n\t\t\t\t\tparent.swap(fallbackBuffer, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallbackBuffer.dispose();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Encoding.\n\t */\n\n\t/** @internal Claims accessors that can be compressed and writes compressed buffer views. */\n\tpublic prewrite(context: WriterContext, propertyType: PropertyType): this {\n\t\tif (propertyType === PropertyType.ACCESSOR) {\n\t\t\tthis._prewriteAccessors(context);\n\t\t} else if (propertyType === PropertyType.BUFFER) {\n\t\t\tthis._prewriteBuffers(context);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @internal Claims accessors that can be compressed. */\n\tprivate _prewriteAccessors(context: WriterContext): void {\n\t\tconst json = context.jsonDoc.json;\n\t\tconst encoder = this._encoder!;\n\t\tconst options = this._encoderOptions;\n\n\t\tconst fallbackBuffer = this.document.createBuffer(); // Disposed on write.\n\t\tconst fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);\n\n\t\tthis._encoderFallbackBuffer = fallbackBuffer;\n\t\tthis._encoderBufferViews = {};\n\t\tthis._encoderBufferViewData = {};\n\t\tthis._encoderBufferViewAccessors = {};\n\n\t\tfor (const accessor of this.document.getRoot().listAccessors()) {\n\t\t\t// See: https://github.com/donmccurdy/glTF-Transform/pull/323#issuecomment-898791251\n\t\t\t// Example: https://skfb.ly/6qAD8\n\t\t\tif (getTargetPath(accessor) === 'weights') continue;\n\n\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\tconst mode = getMeshoptMode(accessor, usage);\n\t\t\tconst filter =\n\t\t\t\toptions.method === EncoderMethod.FILTER\n\t\t\t\t\t? getMeshoptFilter(accessor, this.document)\n\t\t\t\t\t: { filter: MeshoptFilter.NONE };\n\t\t\tconst preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);\n\t\t\tconst { array, byteStride } = preparedAccessor;\n\n\t\t\tconst buffer = accessor.getBuffer();\n\t\t\tif (!buffer) throw new Error(`${NAME}: Missing buffer for accessor.`);\n\t\t\tconst bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);\n\n\t\t\t// Buffer view grouping key.\n\t\t\tconst key = [usage, mode, filter.filter, byteStride, bufferIndex].join(':');\n\n\t\t\tlet bufferView = this._encoderBufferViews[key];\n\t\t\tlet bufferViewData = this._encoderBufferViewData[key];\n\t\t\tlet bufferViewAccessors = this._encoderBufferViewAccessors[key];\n\n\t\t\t// Write new buffer view, if needed.\n\t\t\tif (!bufferView || !bufferViewData) {\n\t\t\t\tbufferViewAccessors = this._encoderBufferViewAccessors[key] = [];\n\t\t\t\tbufferViewData = this._encoderBufferViewData[key] = [];\n\t\t\t\tbufferView = this._encoderBufferViews[key] = {\n\t\t\t\t\tbuffer: fallbackBufferIndex,\n\t\t\t\t\ttarget: WriterContext.USAGE_TO_TARGET[usage],\n\t\t\t\t\tbyteOffset: 0,\n\t\t\t\t\tbyteLength: 0,\n\t\t\t\t\tbyteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : undefined,\n\t\t\t\t\textensions: {\n\t\t\t\t\t\t[NAME]: {\n\t\t\t\t\t\t\tbuffer: bufferIndex,\n\t\t\t\t\t\t\tbyteOffset: 0,\n\t\t\t\t\t\t\tbyteLength: 0,\n\t\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\t\tfilter: filter.filter !== MeshoptFilter.NONE ? filter.filter : undefined,\n\t\t\t\t\t\t\tbyteStride: byteStride,\n\t\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Write accessor.\n\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\taccessorDef.componentType = preparedAccessor.componentType;\n\t\t\taccessorDef.normalized = preparedAccessor.normalized;\n\t\t\taccessorDef.byteOffset = bufferView.byteLength;\n\t\t\tif (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;\n\t\t\tif (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;\n\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\tjson.accessors!.push(accessorDef);\n\t\t\tbufferViewAccessors.push(accessorDef);\n\n\t\t\t// Update buffer view.\n\t\t\tbufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\n\t\t\tbufferView.byteLength += array.byteLength;\n\t\t\tbufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();\n\t\t}\n\t}\n\n\t/** @internal Writes compressed buffer views. */\n\tprivate _prewriteBuffers(context: WriterContext): void {\n\t\tconst encoder = this._encoder!;\n\n\t\tfor (const key in this._encoderBufferViews) {\n\t\t\tconst bufferView = this._encoderBufferViews[key];\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key];\n\t\t\tconst buffer = this.document.getRoot().listBuffers()[bufferView.extensions[NAME].buffer];\n\t\t\tconst otherBufferViews = context.otherBufferViews.get(buffer) || [];\n\n\t\t\tconst { count, byteStride, mode } = bufferView.extensions[NAME];\n\t\t\tconst srcArray = BufferUtils.concat(bufferViewData);\n\t\t\tconst dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);\n\t\t\tconst compressedData = BufferUtils.pad(dstArray);\n\n\t\t\tbufferView.extensions[NAME].byteLength = dstArray.byteLength;\n\n\t\t\tbufferViewData.length = 0;\n\t\t\tbufferViewData.push(compressedData);\n\t\t\totherBufferViews.push(compressedData);\n\t\t\tcontext.otherBufferViews.set(buffer, otherBufferViews);\n\t\t}\n\t}\n\n\t/** @hidden Puts encoded data into glTF output. */\n\tpublic write(context: WriterContext): this {\n\t\tlet fallbackBufferByteOffset = 0;\n\n\t\t// Write final encoded buffer view properties.\n\t\tfor (const key in this._encoderBufferViews) {\n\t\t\tconst bufferView = this._encoderBufferViews[key];\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key][0];\n\t\t\tconst bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData)!;\n\n\t\t\tconst bufferViewAccessors = this._encoderBufferViewAccessors[key];\n\t\t\tfor (const accessorDef of bufferViewAccessors) {\n\t\t\t\taccessorDef.bufferView = bufferViewIndex;\n\t\t\t}\n\n\t\t\tconst finalBufferViewDef = context.jsonDoc.json.bufferViews![bufferViewIndex];\n\t\t\tconst compressedByteOffset = finalBufferViewDef.byteOffset || 0;\n\n\t\t\tObject.assign(finalBufferViewDef, bufferView);\n\t\t\tfinalBufferViewDef.byteOffset = fallbackBufferByteOffset;\n\t\t\tconst bufferViewExtensionDef = finalBufferViewDef.extensions![NAME] as MeshoptBufferViewExtension;\n\t\t\tbufferViewExtensionDef.byteOffset = compressedByteOffset;\n\n\t\t\tfallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);\n\t\t}\n\n\t\t// Write final fallback buffer.\n\t\tconst fallbackBuffer = this._encoderFallbackBuffer!;\n\t\tconst fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer)!;\n\t\tconst fallbackBufferDef = context.jsonDoc.json.buffers![fallbackBufferIndex];\n\t\tfallbackBufferDef.byteLength = fallbackBufferByteOffset;\n\t\tfallbackBufferDef.extensions = { [NAME]: { fallback: true } };\n\t\tfallbackBuffer.dispose();\n\n\t\treturn this;\n\t}\n}\n","import { EXT_MESHOPT_COMPRESSION } from '../constants';\nimport { GLTF } from '@gltf-transform/core';\nimport { MeshoptBufferExtension } from './constants';\n\n/**\n * Returns true for a fallback buffer, else false.\n *\n *   - All references to the fallback buffer must come from bufferViews that\n *     have a EXT_meshopt_compression extension specified.\n *   - No references to the fallback buffer may come from\n *     EXT_meshopt_compression extension JSON.\n */\nexport function isFallbackBuffer(bufferDef: GLTF.IBuffer): boolean {\n\tif (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;\n\tconst fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION] as MeshoptBufferExtension;\n\treturn !!fallbackDef.fallback;\n}\n","import {\n\tBufferUtils,\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n} from '@gltf-transform/core';\nimport { EXT_TEXTURE_WEBP } from '../constants';\n\nconst NAME = EXT_TEXTURE_WEBP;\n\nclass WEBPImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;\n\t}\n\tgetSize(array: Uint8Array): vec2 | null {\n\t\t// Reference: http://tools.ietf.org/html/rfc6386\n\t\tconst RIFF = BufferUtils.decodeText(array.slice(0, 4));\n\t\tconst WEBP = BufferUtils.decodeText(array.slice(8, 12));\n\t\tif (RIFF !== 'RIFF' || WEBP !== 'WEBP') return null;\n\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\n\n\t\t// Reference: https://wiki.tcl-lang.org/page/Reading+WEBP+image+dimensions\n\t\tlet offset = 12;\n\t\twhile (offset < view.byteLength) {\n\t\t\tconst chunkId = BufferUtils.decodeText(\n\t\t\t\tnew Uint8Array([\n\t\t\t\t\tview.getUint8(offset),\n\t\t\t\t\tview.getUint8(offset + 1),\n\t\t\t\t\tview.getUint8(offset + 2),\n\t\t\t\t\tview.getUint8(offset + 3),\n\t\t\t\t])\n\t\t\t);\n\t\t\tconst chunkByteLength = view.getUint32(offset + 4, true);\n\t\t\tif (chunkId === 'VP8 ') {\n\t\t\t\tconst width = view.getInt16(offset + 14, true) & 0x3fff;\n\t\t\t\tconst height = view.getInt16(offset + 16, true) & 0x3fff;\n\t\t\t\treturn [width, height];\n\t\t\t} else if (chunkId === 'VP8L') {\n\t\t\t\tconst b0 = view.getUint8(offset + 9);\n\t\t\t\tconst b1 = view.getUint8(offset + 10);\n\t\t\t\tconst b2 = view.getUint8(offset + 11);\n\t\t\t\tconst b3 = view.getUint8(offset + 12);\n\t\t\t\tconst width = 1 + (((b1 & 0x3f) << 8) | b0);\n\t\t\t\tconst height = 1 + (((b3 & 0xf) << 10) | (b2 << 2) | ((b1 & 0xc0) >> 6));\n\t\t\t\treturn [width, height];\n\t\t\t}\n\t\t\toffset += 8 + chunkByteLength + (chunkByteLength % 2);\n\t\t}\n\n\t\treturn null;\n\t}\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * # TextureWebP\n *\n * [`EXT_texture_webp`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp/)\n * enables WebP images for any material texture.\n *\n * [[include:VENDOR_EXTENSIONS_NOTE.md]]\n *\n * WebP typically provides the minimal transmission\n * size, but [requires browser support](https://caniuse.com/webp). Like PNG and JPEG, a WebP image is\n * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.\n * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format\n * like Basis Universal, with the `KHR_texture_basisu` extension.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/webp` MIME type\n * and passing WebP image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { TextureWebP } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const webpExtension = document.createExtension(TextureWebP)\n * \t.setRequired(true);\n * document.createTexture('MyWebPTexture')\n * \t.setMimeType('image/webp')\n * \t.setImage(fs.readFileSync('my-texture.webp'));\n * ```\n *\n * WebP conversion is not done automatically when adding the extension as shown above — you must\n * convert the image data first, then pass the `.webp` payload to {@link Texture.setImage}.\n *\n * When the `EXT_texture_webp` extension is added to a file by glTF-Transform, the extension should\n * always be required. This tool does not support writing assets that \"fall back\" to optional PNG or\n * JPEG image data.\n */\nexport class TextureWebP extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/webp', new WEBPImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst textureDefs = context.jsonDoc.json.textures || [];\n\t\ttextureDefs.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\ttextureDef.source = (textureDef.extensions[NAME] as { source: number }).source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/webp') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\t\t\t\ttextureDefs.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { Accessor, GLTF, TypedArray, TypedArrayConstructor } from '@gltf-transform/core';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\nimport type { Attribute, DataType, Decoder, DecoderModule, Mesh } from 'draco3dgltf';\n\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\n\nexport let decoderModule: DecoderModule;\n\n// Initialized when decoder module loads.\nlet COMPONENT_ARRAY: { [key: number]: TypedArrayConstructor };\nlet DATA_TYPE: { [key: number]: DataType };\n\nexport function decodeGeometry(decoder: Decoder, data: Uint8Array): Mesh {\n\tconst buffer = new decoderModule.DecoderBuffer();\n\ttry {\n\t\tbuffer.Init(data as unknown as Int8Array, data.length);\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType(buffer);\n\t\tif (geometryType !== decoderModule.TRIANGULAR_MESH) {\n\t\t\tthrow new Error(`[${NAME}] Unknown geometry type.`);\n\t\t}\n\n\t\tconst dracoMesh = new decoderModule.Mesh();\n\t\tconst status = decoder.DecodeBufferToMesh(buffer, dracoMesh);\n\n\t\tif (!status.ok() || dracoMesh.ptr === 0) {\n\t\t\tthrow new Error(`[${NAME}] Decoding failure.`);\n\t\t}\n\n\t\treturn dracoMesh;\n\t} finally {\n\t\tdecoderModule.destroy(buffer);\n\t}\n}\n\nexport function decodeIndex(decoder: Decoder, mesh: Mesh): Uint16Array | Uint32Array {\n\tconst numFaces = mesh.num_faces();\n\tconst numIndices = numFaces * 3;\n\n\tlet ptr: number;\n\tlet indices: Uint16Array | Uint32Array;\n\n\tif (mesh.num_points() <= 65534) {\n\t\tconst byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;\n\t\tptr = decoderModule._malloc(byteLength);\n\t\tdecoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);\n\t\tindices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\n\t} else {\n\t\tconst byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;\n\t\tptr = decoderModule._malloc(byteLength);\n\t\tdecoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n\t\tindices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\n\t}\n\n\tdecoderModule._free(ptr);\n\n\treturn indices;\n}\n\nexport function decodeAttribute(\n\tdecoder: Decoder,\n\tmesh: Mesh,\n\tattribute: Attribute,\n\taccessorDef: GLTF.IAccessor\n): TypedArray {\n\tconst dataType = DATA_TYPE[accessorDef.componentType];\n\tconst ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];\n\tconst numComponents = attribute.num_components();\n\tconst numPoints = mesh.num_points();\n\tconst numValues = numPoints * numComponents;\n\tconst byteLength: number = numValues * ArrayCtor.BYTES_PER_ELEMENT;\n\n\tconst ptr = decoderModule._malloc(byteLength);\n\tdecoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);\n\tconst array: TypedArray = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\n\tdecoderModule._free(ptr);\n\n\treturn array;\n}\n\nexport function initDecoderModule(_decoderModule: DecoderModule): void {\n\tdecoderModule = _decoderModule;\n\n\tCOMPONENT_ARRAY = {\n\t\t[Accessor.ComponentType.FLOAT]: Float32Array,\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,\n\t\t[Accessor.ComponentType.SHORT]: Int16Array,\n\t\t[Accessor.ComponentType.BYTE]: Int8Array,\n\t};\n\n\tDATA_TYPE = {\n\t\t[Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,\n\t\t[Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,\n\t\t[Accessor.ComponentType.BYTE]: decoderModule.DT_INT8,\n\t};\n}\n","import { Accessor, bbox, GLTF, Primitive, TypedArray } from '@gltf-transform/core';\nimport type { EncoderModule, Mesh, MeshBuilder } from 'draco3dgltf';\n\nexport let encoderModule: EncoderModule;\n\nexport enum EncoderMethod {\n\tEDGEBREAKER = 1,\n\tSEQUENTIAL = 0,\n}\n\nenum AttributeEnum {\n\tPOSITION = 'POSITION',\n\tNORMAL = 'NORMAL',\n\tCOLOR = 'COLOR',\n\tTEX_COORD = 'TEX_COORD',\n\tGENERIC = 'GENERIC',\n}\n\nconst DEFAULT_QUANTIZATION_BITS = {\n\t[AttributeEnum.POSITION]: 14,\n\t[AttributeEnum.NORMAL]: 10,\n\t[AttributeEnum.COLOR]: 8,\n\t[AttributeEnum.TEX_COORD]: 12,\n\t[AttributeEnum.GENERIC]: 12,\n};\n\nexport interface EncodedPrimitive {\n\tnumVertices: number;\n\tnumIndices: number;\n\tdata: Uint8Array;\n\tattributeIDs: { [key: string]: number };\n}\n\nexport interface EncoderOptions {\n\tdecodeSpeed?: number;\n\tencodeSpeed?: number;\n\tmethod?: EncoderMethod;\n\tquantizationBits?: { [key: string]: number };\n\tquantizationVolume?: 'mesh' | 'scene' | bbox;\n}\n\nconst DEFAULT_ENCODER_OPTIONS: EncoderOptions = {\n\tdecodeSpeed: 5,\n\tencodeSpeed: 5,\n\tmethod: EncoderMethod.EDGEBREAKER,\n\tquantizationBits: DEFAULT_QUANTIZATION_BITS,\n\tquantizationVolume: 'mesh',\n};\n\nexport function initEncoderModule(_encoderModule: EncoderModule): void {\n\tencoderModule = _encoderModule;\n}\n\n/**\n * References:\n * - https://github.com/mrdoob/three.js/blob/dev/examples/js/exporters/DRACOExporter.js\n * - https://github.com/CesiumGS/gltf-pipeline/blob/master/lib/compressDracoMeshes.js\n */\nexport function encodeGeometry(prim: Primitive, _options: EncoderOptions = DEFAULT_ENCODER_OPTIONS): EncodedPrimitive {\n\tconst options = { ...DEFAULT_ENCODER_OPTIONS, ..._options } as Required<EncoderOptions>;\n\toptions.quantizationBits = { ...DEFAULT_QUANTIZATION_BITS, ..._options.quantizationBits };\n\n\tconst encoder = new encoderModule.Encoder();\n\tconst builder = new encoderModule.MeshBuilder();\n\tconst mesh = new encoderModule.Mesh();\n\n\tconst attributeIDs: { [key: string]: number } = {};\n\tconst dracoBuffer = new encoderModule.DracoInt8Array();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tconst attributeEnum = getAttributeEnum(semantic);\n\t\tconst attributeID: number = addAttribute(\n\t\t\tbuilder,\n\t\t\tattribute.getComponentType(),\n\t\t\tmesh,\n\t\t\tencoderModule[attributeEnum],\n\t\t\tattribute.getCount(),\n\t\t\tattribute.getElementSize(),\n\t\t\tattribute.getArray()!\n\t\t);\n\n\t\tif (attributeID === -1) throw new Error(`Error compressing \"${semantic}\" attribute.`);\n\n\t\tattributeIDs[semantic] = attributeID;\n\t\tif (options.quantizationVolume === 'mesh' || semantic !== 'POSITION') {\n\t\t\tencoder.SetAttributeQuantization(encoderModule[attributeEnum], options.quantizationBits[attributeEnum]);\n\t\t} else if (typeof options.quantizationVolume === 'object') {\n\t\t\tconst { quantizationVolume } = options;\n\t\t\tconst range = Math.max(\n\t\t\t\tquantizationVolume.max[0] - quantizationVolume.min[0],\n\t\t\t\tquantizationVolume.max[1] - quantizationVolume.min[1],\n\t\t\t\tquantizationVolume.max[2] - quantizationVolume.min[2]\n\t\t\t);\n\t\t\tencoder.SetAttributeExplicitQuantization(\n\t\t\t\tencoderModule[attributeEnum],\n\t\t\t\toptions.quantizationBits[attributeEnum],\n\t\t\t\tattribute.getElementSize(),\n\t\t\t\tquantizationVolume.min,\n\t\t\t\trange\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error('Invalid quantization volume state.');\n\t\t}\n\t}\n\n\tconst indices = prim.getIndices();\n\tif (!indices) throw new Error('Primitive must have indices.');\n\n\tbuilder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray() as unknown as Uint32Array);\n\n\tencoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\n\tencoder.SetTrackEncodedProperties(true);\n\n\t// Preserve vertex order for primitives with morph targets.\n\tif (options.method === EncoderMethod.SEQUENTIAL || prim.listTargets().length > 0) {\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);\n\t} else {\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);\n\t}\n\n\tconst byteLength = encoder.EncodeMeshToDracoBuffer(mesh, dracoBuffer);\n\tif (byteLength <= 0) throw new Error('Error applying Draco compression.');\n\n\tconst data = new Uint8Array(byteLength);\n\tfor (let i = 0; i < byteLength; ++i) {\n\t\tdata[i] = dracoBuffer.GetValue(i);\n\t}\n\n\tconst prevNumVertices = prim.getAttribute('POSITION')!.getCount();\n\tconst numVertices = encoder.GetNumberOfEncodedPoints();\n\tconst numIndices = encoder.GetNumberOfEncodedFaces() * 3;\n\n\tif (prim.listTargets().length > 0 && numVertices !== prevNumVertices) {\n\t\tthrow new Error(\n\t\t\t'Compression reduced vertex count unexpectedly, corrupting morph targets.' +\n\t\t\t\t' Applying the \"weld\" function before compression may resolve the issue.'\n\t\t);\n\t}\n\n\tencoderModule.destroy(dracoBuffer);\n\tencoderModule.destroy(mesh);\n\tencoderModule.destroy(builder);\n\tencoderModule.destroy(encoder);\n\n\treturn { numVertices, numIndices, data, attributeIDs };\n}\n\nfunction getAttributeEnum(semantic: string): AttributeEnum {\n\tif (semantic === 'POSITION') {\n\t\treturn AttributeEnum.POSITION;\n\t} else if (semantic === 'NORMAL') {\n\t\treturn AttributeEnum.NORMAL;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\treturn AttributeEnum.COLOR;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\treturn AttributeEnum.TEX_COORD;\n\t}\n\treturn AttributeEnum.GENERIC;\n}\n\nfunction addAttribute(\n\tbuilder: MeshBuilder,\n\tcomponentType: GLTF.AccessorComponentType,\n\tmesh: Mesh,\n\tattribute: number,\n\tcount: number,\n\titemSize: number,\n\tarray: TypedArray\n): number {\n\tswitch (componentType) {\n\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\treturn builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.BYTE:\n\t\t\treturn builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\treturn builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.SHORT:\n\t\t\treturn builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\treturn builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\treturn builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);\n\t\tdefault:\n\t\t\tthrow new Error(`Unexpected component type, \"${componentType}\".`);\n\t}\n}\n","import {\n\tAccessor,\n\tbbox,\n\tbounds,\n\tBufferUtils,\n\tDocument,\n\tExtension,\n\tGLB_BUFFER,\n\tPrimitive,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { decodeAttribute, decodeGeometry, decodeIndex, initDecoderModule } from './decoder';\nimport { EncodedPrimitive, encodeGeometry, EncoderMethod, EncoderOptions, initEncoderModule } from './encoder';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants';\nimport type { Decoder, DecoderModule, EncoderModule, Mesh } from 'draco3dgltf';\n\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\n\ninterface DracoPrimitiveExtension {\n\tbufferView: number;\n\tattributes: {\n\t\t[name: string]: number;\n\t};\n}\n\ninterface DracoWriterContext {\n\tprimitiveHashMap: Map<Primitive, string>;\n\tprimitiveEncodingMap: Map<string, EncodedPrimitive>;\n}\n\n/**\n * # DracoMeshCompression\n *\n * [`KHR_draco_mesh_compression`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/)\n * provides advanced compression for mesh geometry.\n *\n * For models where geometry is a significant factor (>1 MB), Draco can reduce filesize by ~95%\n * in many cases. When animation or textures are large, other complementary compression methods\n * should be used as well. For geometry <1MB, the size of the WASM decoder library may outweigh\n * size savings.\n *\n * Be aware that decompression happens before uploading to the GPU — this will add some latency to\n * the parsing process, and means that compressing geometry with  Draco does _not_ affect runtime\n * performance. To improve framerate, you'll need to simplify the geometry by reducing vertex count\n * or draw calls — not just compress it. Finally, be aware that Draco compression is lossy:\n * repeatedly compressing and decompressing a model in a pipeline will lose precision, so\n * compression should generally be the last stage of an art workflow, and uncompressed original\n * files should be kept.\n *\n * A decoder or encoder from the `draco3dgltf` npm module for Node.js (or\n * [elsewhere for web](https://stackoverflow.com/a/66978236/1314762)) is required for reading and writing,\n * and must be provided by the application.\n *\n * ### Encoding options\n *\n * Two compression methods are available: 'edgebreaker' and 'sequential'. The\n * edgebreaker method will give higher compression in general, but changes the\n * order of the model's vertices. To preserve index order, use sequential\n * compression. When a mesh uses morph targets, or a high decoding speed is\n * selected, sequential compression will automatically be chosen.\n *\n * Both speed options affect the encoder's choice of algorithms. For example, a\n * requirement for fast decoding may prevent the encoder from using the best\n * compression methods even if the encoding speed is set to 0. In general, the\n * faster of the two options limits the choice of features that can be used by the\n * encoder. Setting --decodeSpeed to be faster than the --encodeSpeed may allow\n * the encoder to choose the optimal method out of the available features for the\n * given --decodeSpeed.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { DracoMeshCompression } from '@gltf-transform/extensions';\n *\n * import draco3d from 'draco3dgltf';\n *\n * // ...\n *\n * const io = new NodeIO()\n *\t.registerExtensions([DracoMeshCompression])\n *\t.registerDependencies({\n *\t\t'draco3d.decoder': await draco3d.createDecoderModule(), // Optional.\n *\t\t'draco3d.encoder': await draco3d.createEncoderModule(), // Optional.\n *\t});\n *\n * // Read and decode.\n * const document = await io.read('compressed.glb');\n *\n * // Write and encode.\n * document.createExtension(DracoMeshCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({\n * \t\tmethod: DracoMeshCompression.EncoderMethod.EDGEBREAKER,\n * \t\tencodeSpeed: 5,\n * \t\tdecodeSpeed: 5,\n * \t});\n * await io.write('compressed.glb', document);\n * ```\n */\nexport class DracoMeshCompression extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.PRIMITIVE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\n\t/** @hidden */\n\tpublic readonly readDependencies = ['draco3d.decoder'];\n\t/** @hidden */\n\tpublic readonly writeDependencies = ['draco3d.encoder'];\n\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/**\n\t * Compression method. `EncoderMethod.EDGEBREAKER` usually provides a higher compression ratio,\n\t * while `EncoderMethod.SEQUENTIAL` better preserves original verter order.\n\t */\n\tpublic static readonly EncoderMethod = EncoderMethod;\n\n\tprivate _decoderModule: DecoderModule | null = null;\n\tprivate _encoderModule: EncoderModule | null = null;\n\tprivate _encoderOptions: EncoderOptions = {};\n\n\t/** @hidden */\n\tpublic install(key: string, dependency: unknown): this {\n\t\tif (key === 'draco3d.decoder') {\n\t\t\tthis._decoderModule = dependency as DecoderModule;\n\t\t\tinitDecoderModule(this._decoderModule);\n\t\t}\n\t\tif (key === 'draco3d.encoder') {\n\t\t\tthis._encoderModule = dependency as EncoderModule;\n\t\t\tinitEncoderModule(this._encoderModule);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets Draco compression options. Compression does not take effect until the Document is\n\t * written with an I/O class.\n\t *\n\t * Defaults:\n\t * ```\n\t * decodeSpeed?: number = 5;\n\t * encodeSpeed?: number = 5;\n\t * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;\n\t * quantizationBits?: {[ATTRIBUTE_NAME]: bits};\n\t * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';\n\t * ```\n\t */\n\tpublic setEncoderOptions(options: EncoderOptions): this {\n\t\tthis._encoderOptions = options;\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tif (!this._decoderModule) {\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.decoder\".`);\n\t\t}\n\n\t\tconst logger = this.document.getLogger();\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst dracoMeshes: Map<number, [Decoder, Mesh]> = new Map();\n\n\t\ttry {\n\t\t\tconst meshDefs = jsonDoc.json.meshes || [];\n\t\t\tfor (const meshDef of meshDefs) {\n\t\t\t\tfor (const primDef of meshDef.primitives) {\n\t\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) continue;\n\n\t\t\t\t\tconst dracoDef = primDef.extensions[NAME] as DracoPrimitiveExtension;\n\t\t\t\t\tlet [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];\n\n\t\t\t\t\tif (!dracoMesh || !decoder) {\n\t\t\t\t\t\tconst bufferViewDef = jsonDoc.json.bufferViews![dracoDef.bufferView];\n\t\t\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\n\t\t\t\t\t\tconst resource = bufferDef.uri\n\t\t\t\t\t\t\t? jsonDoc.resources[bufferDef.uri]\n\t\t\t\t\t\t\t: jsonDoc.resources[GLB_BUFFER];\n\n\t\t\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\t\t\tconst compressedData = BufferUtils.toView(resource, byteOffset, byteLength);\n\n\t\t\t\t\t\tdecoder = new this._decoderModule.Decoder();\n\t\t\t\t\t\tdracoMesh = decodeGeometry(decoder, compressedData);\n\t\t\t\t\t\tdracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);\n\t\t\t\t\t\tlogger.debug(`[${NAME}] Decompressed ${compressedData.byteLength} bytes.`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attributes.\n\t\t\t\t\tfor (const semantic in primDef.attributes) {\n\t\t\t\t\t\tconst accessorDef = context.jsonDoc.json.accessors![primDef.attributes[semantic]];\n\t\t\t\t\t\tconst dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);\n\t\t\t\t\t\tconst attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);\n\t\t\t\t\t\tcontext.accessors[primDef.attributes[semantic]].setArray(attributeArray);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Indices. Optional, see https://github.com/google/draco/issues/720.\n\t\t\t\t\tif (primDef.indices !== undefined) {\n\t\t\t\t\t\tcontext.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tfor (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {\n\t\t\t\tthis._decoderModule.destroy(decoder);\n\t\t\t\tthis._decoderModule.destroy(dracoMesh);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext, _propertyType: PropertyType): this {\n\t\tif (!this._encoderModule) {\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.encoder\".`);\n\t\t}\n\n\t\tconst logger = this.document.getLogger();\n\t\tlogger.debug(`[${NAME}] Compression options: ${JSON.stringify(this._encoderOptions)}`);\n\n\t\tconst primitiveHashMap = listDracoPrimitives(this.document);\n\t\tconst primitiveEncodingMap = new Map<string, EncodedPrimitive>();\n\n\t\tlet quantizationVolume: bbox | 'mesh' = 'mesh';\n\t\tif (this._encoderOptions.quantizationVolume === 'scene') {\n\t\t\tif (this.document.getRoot().listScenes().length !== 1) {\n\t\t\t\tlogger.warn(`[${NAME}]: quantizationVolume=scene requires exactly 1 scene.`);\n\t\t\t} else {\n\t\t\t\tquantizationVolume = bounds(this.document.getRoot().listScenes().pop()!);\n\t\t\t}\n\t\t}\n\n\t\tfor (const prim of Array.from(primitiveHashMap.keys())) {\n\t\t\tconst primHash = primitiveHashMap.get(prim);\n\t\t\tif (!primHash) throw new Error('Unexpected primitive.');\n\n\t\t\t// Reuse an existing EncodedPrimitive, if possible.\n\t\t\tif (primitiveEncodingMap.has(primHash)) {\n\t\t\t\tprimitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash)!);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst indices = prim.getIndices()!; // Condition for listDracoPrimitives().\n\t\t\tconst accessorDefs = context.jsonDoc.json.accessors!;\n\n\t\t\t// Create a new EncodedPrimitive.\n\t\t\tconst encodedPrim = encodeGeometry(prim, { ...this._encoderOptions, quantizationVolume });\n\t\t\tprimitiveEncodingMap.set(primHash, encodedPrim);\n\n\t\t\t// Create indices definition, update count.\n\t\t\tconst indicesDef = context.createAccessorDef(indices);\n\t\t\tindicesDef.count = encodedPrim.numIndices;\n\t\t\tcontext.accessorIndexMap.set(indices, accessorDefs.length);\n\t\t\taccessorDefs.push(indicesDef);\n\n\t\t\t// Create attribute definitions, update count.\n\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\tconst attributeDef = context.createAccessorDef(attribute);\n\t\t\t\tattributeDef.count = encodedPrim.numVertices;\n\t\t\t\tcontext.accessorIndexMap.set(attribute, accessorDefs.length);\n\t\t\t\taccessorDefs.push(attributeDef);\n\t\t\t}\n\n\t\t\t// Map compressed buffer view to a Buffer.\n\t\t\tconst buffer = prim.getAttribute('POSITION')!.getBuffer() || this.document.getRoot().listBuffers()[0];\n\t\t\tif (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);\n\t\t\tcontext.otherBufferViews.get(buffer)!.push(encodedPrim.data);\n\t\t}\n\n\t\tlogger.debug(`[${NAME}] Compressed ${primitiveHashMap.size} primitives.`);\n\n\t\tcontext.extensionData[NAME] = {\n\t\t\tprimitiveHashMap,\n\t\t\tprimitiveEncodingMap,\n\t\t} as DracoWriterContext;\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst dracoContext: DracoWriterContext = context.extensionData[NAME] as DracoWriterContext;\n\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\n\t\t\tconst meshDef = context.jsonDoc.json.meshes![context.meshIndexMap.get(mesh)!];\n\t\t\tfor (let i = 0; i < mesh.listPrimitives().length; i++) {\n\t\t\t\tconst prim = mesh.listPrimitives()[i];\n\t\t\t\tconst primDef = meshDef.primitives[i];\n\n\t\t\t\tconst primHash = dracoContext.primitiveHashMap.get(prim);\n\t\t\t\tif (!primHash) continue;\n\n\t\t\t\tconst encodedPrim = dracoContext.primitiveEncodingMap.get(primHash)!;\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\n\t\t\t\tprimDef.extensions[NAME] = {\n\t\t\t\t\tbufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),\n\t\t\t\t\tattributes: encodedPrim.attributeIDs,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Omit the extension if nothing was compressed.\n\t\tif (!dracoContext.primitiveHashMap.size) {\n\t\t\tconst json = context.jsonDoc.json;\n\t\t\tjson.extensionsUsed = (json.extensionsUsed || []).filter((name) => name !== NAME);\n\t\t\tjson.extensionsRequired = (json.extensionsRequired || []).filter((name) => name !== NAME);\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * Returns a list of Primitives compatible with Draco compression. If any required preconditions\n * fail, and would break assumptions required for compression, this function will throw an error.\n */\nfunction listDracoPrimitives(doc: Document): Map<Primitive, string> {\n\tconst logger = doc.getLogger();\n\tconst included = new Set<Primitive>();\n\tconst excluded = new Set<Primitive>();\n\n\t// Support compressing only indexed, mode=TRIANGLES primitives.\n\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tif (!prim.getIndices()) {\n\t\t\t\texcluded.add(prim);\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-indexed primitive.`);\n\t\t\t} else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {\n\t\t\t\texcluded.add(prim);\n\t\t\t\tlogger.warn(`[${NAME}] Skipping Draco compression on non-TRIANGLES primitive.`);\n\t\t\t} else {\n\t\t\t\tincluded.add(prim);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Create an Accessor->index mapping.\n\tconst accessors = doc.getRoot().listAccessors();\n\tconst accessorIndices = new Map<Accessor, number>();\n\tfor (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);\n\n\t// For each compressed Primitive, create a hash key identifying its accessors. Map each\n\t// compressed Primitive and Accessor to this hash key.\n\tconst includedAccessors = new Map<Accessor, string>();\n\tconst includedHashKeys = new Set<string>();\n\tconst primToHashKey = new Map<Primitive, string>();\n\tfor (const prim of Array.from(included)) {\n\t\tlet hashKey = createHashKey(prim, accessorIndices);\n\n\t\t// If accessors of an identical primitive have already been checked, we're done.\n\t\tif (includedHashKeys.has(hashKey)) {\n\t\t\tprimToHashKey.set(prim, hashKey);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If any accessors are already in use, but the same hashKey hasn't been written, then we\n\t\t// need to create copies of these accessors for the current encoded primitive. We can't\n\t\t// reuse the same compressed accessor for two encoded primitives, because Draco might\n\t\t// change the vertex count, change the vertex order, or cause other conflicts.\n\t\tif (includedAccessors.has(prim.getIndices()!)) {\n\t\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\t\tconst dstIndices = indices.clone();\n\t\t\taccessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);\n\t\t\tprim.swap(indices, dstIndices); // TODO(cleanup): I/O should not modify Document.\n\t\t}\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tif (includedAccessors.has(attribute)) {\n\t\t\t\tconst dstAttribute = attribute.clone();\n\t\t\t\taccessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);\n\t\t\t\tprim.swap(attribute, dstAttribute); // TODO(cleanup): I/O should not modify Document.\n\t\t\t}\n\t\t}\n\n\t\t// With conflicts resolved, compute the hash key again.\n\t\thashKey = createHashKey(prim, accessorIndices);\n\n\t\t// Commit the primitive and its accessors to the hash key.\n\t\tincludedHashKeys.add(hashKey);\n\t\tprimToHashKey.set(prim, hashKey);\n\t\tincludedAccessors.set(prim.getIndices()!, hashKey);\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tincludedAccessors.set(attribute, hashKey);\n\t\t}\n\t}\n\n\t// For each compressed Accessor, ensure that it isn't used except by a Primitive.\n\tfor (const accessor of Array.from(includedAccessors.keys())) {\n\t\tconst parentTypes = new Set(accessor.listParents().map((prop) => prop.propertyType));\n\t\tif (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {\n\t\t\tthrow new Error(`[${NAME}] Compressed accessors must only be used as indices or vertex attributes.`);\n\t\t}\n\t}\n\n\t// For each compressed Primitive, ensure that Accessors are mapped only to the same hash key.\n\tfor (const prim of Array.from(included)) {\n\t\tconst hashKey = primToHashKey.get(prim);\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\tif (\n\t\t\tincludedAccessors.get(indices) !== hashKey ||\n\t\t\tprim.listAttributes().some((attr) => includedAccessors.get(attr) !== hashKey)\n\t\t) {\n\t\t\tthrow new Error(`[${NAME}] Draco primitives must share all, or no, accessors.`);\n\t\t}\n\t}\n\n\t// For each excluded Primitive, ensure that no Accessors are compressed.\n\tfor (const prim of Array.from(excluded)) {\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\tif (includedAccessors.has(indices) || prim.listAttributes().some((attr) => includedAccessors.has(attr))) {\n\t\t\tthrow new Error(`[${NAME}] Accessor cannot be shared by compressed and uncompressed primitives.`);\n\t\t}\n\t}\n\n\treturn primToHashKey;\n}\n\nfunction createHashKey(prim: Primitive, indexMap: Map<Accessor, number>): string {\n\tconst hashElements = [];\n\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\n\thashElements.push(indexMap.get(indices));\n\tfor (const attribute of prim.listAttributes()) {\n\t\thashElements.push(indexMap.get(attribute));\n\t}\n\n\treturn hashElements.sort().join('|');\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType, vec3 } from '@gltf-transform/core';\nimport { ColorUtils } from '@gltf-transform/core';\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\n\ninterface ILight extends IProperty {\n\tcolor: vec3;\n\tintensity: number;\n\ttype: PunctualLightType;\n\trange: number | null;\n\tinnerConeAngle: number;\n\touterConeAngle: number;\n}\n\ntype PunctualLightType = 'point' | 'spot' | 'directional';\n\n/**\n * # Light\n *\n * Defines a light attached to a {@link Node}. See {@link LightsPunctual}.\n */\nexport class Light extends ExtensionProperty<ILight> {\n\tpublic static EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;\n\tpublic declare extensionName: typeof KHR_LIGHTS_PUNCTUAL;\n\tpublic declare propertyType: 'Light';\n\tpublic declare parentTypes: [PropertyType.NODE];\n\n\t/**********************************************************************************************\n\t * CONSTANTS.\n\t */\n\n\tpublic static Type: Record<string, PunctualLightType> = {\n\t\tPOINT: 'point',\n\t\tSPOT: 'spot',\n\t\tDIRECTIONAL: 'directional',\n\t};\n\n\t/**********************************************************************************************\n\t * INSTANCE.\n\t */\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_LIGHTS_PUNCTUAL;\n\t\tthis.propertyType = 'Light';\n\t\tthis.parentTypes = [PropertyType.NODE];\n\t}\n\n\tprotected getDefaults(): Nullable<ILight> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tcolor: [1, 1, 1] as vec3,\n\t\t\tintensity: 1,\n\t\t\ttype: Light.Type.POINT,\n\t\t\trange: null,\n\t\t\tinnerConeAngle: 0,\n\t\t\touterConeAngle: Math.PI / 4,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * COLOR.\n\t */\n\n\t/** Components (R, G, B) of light's color in linear space. */\n\tpublic getColor(): vec3 {\n\t\treturn this.get('color');\n\t}\n\n\t/** Components (R, G, B) of light's color in linear space. */\n\tpublic setColor(color: vec3): this {\n\t\treturn this.set('color', color);\n\t}\n\n\t/** Hex light color in sRGB colorspace. */\n\tpublic getColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getColor());\n\t}\n\n\t/** Hex light color in sRGB colorspace. */\n\tpublic setColorHex(hex: number): this {\n\t\tconst color = this.getColor().slice() as vec3;\n\t\tColorUtils.hexToFactor(hex, color);\n\t\treturn this.setColor(color);\n\t}\n\n\t/**********************************************************************************************\n\t * INTENSITY.\n\t */\n\n\t/**\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n\t */\n\tpublic getIntensity(): number {\n\t\treturn this.get('intensity');\n\t}\n\n\t/**\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n\t */\n\tpublic setIntensity(intensity: number): this {\n\t\treturn this.set('intensity', intensity);\n\t}\n\n\t/**********************************************************************************************\n\t * TYPE.\n\t */\n\n\t/** Type. */\n\tpublic getType(): PunctualLightType {\n\t\treturn this.get('type');\n\t}\n\n\t/** Type. */\n\tpublic setType(type: PunctualLightType): this {\n\t\treturn this.set('type', type);\n\t}\n\n\t/**********************************************************************************************\n\t * RANGE.\n\t */\n\n\t/**\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n\t * is assumed to be infinite.\n\t */\n\tpublic getRange(): number | null {\n\t\treturn this.get('range');\n\t}\n\n\t/**\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n\t * is assumed to be infinite.\n\t */\n\tpublic setRange(range: number | null): this {\n\t\treturn this.set('range', range);\n\t}\n\n\t/**********************************************************************************************\n\t * SPOT LIGHT PROPERTIES\n\t */\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be ≥ 0 and\n\t * < outerConeAngle.\n\t */\n\tpublic getInnerConeAngle(): number {\n\t\treturn this.get('innerConeAngle');\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be ≥ 0 and\n\t * < outerConeAngle.\n\t */\n\tpublic setInnerConeAngle(angle: number): this {\n\t\treturn this.set('innerConeAngle', angle);\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n\t * ≤ PI / 2.0.\n\t */\n\tpublic getOuterConeAngle(): number {\n\t\treturn this.get('outerConeAngle');\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n\t * ≤ PI / 2.0.\n\t */\n\tpublic setOuterConeAngle(angle: number): this {\n\t\treturn this.set('outerConeAngle', angle);\n\t}\n}\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants';\nimport { Light } from './light';\n\nconst NAME = KHR_LIGHTS_PUNCTUAL;\n\ninterface LightsPunctualRootDef {\n\tlights?: LightDef[];\n}\n\ninterface LightsPunctualNodeDef {\n\tlight: number;\n}\n\ninterface LightDef {\n\tname?: string;\n\tcolor?: vec3;\n\tintensity?: number;\n\trange?: number;\n\tinnerConeAngle?: number;\n\touterConeAngle?: number;\n\ttype: 'spot' | 'point' | 'directional';\n}\n\n/**\n * # LightsPunctual\n *\n * [`KHR_lights_punctual`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/) defines three \"punctual\" light types: directional, point and\n * spot.\n *\n * Punctual lights are parameterized, infinitely small points that emit light in\n * well-defined directions and intensities. Lights are referenced by nodes and inherit the transform\n * of that node.\n *\n * Properties:\n * - {@link Light}\n *\n * ### Example\n *\n * ```typescript\n * import { LightsPunctual, Light, LightType } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const lightsExtension = document.createExtension(LightsPunctual);\n *\n * // Create a Light property.\n * const light = lightsExtension.createLight()\n *\t.setType(LightType.POINT)\n *\t.setIntensity(2.0)\n *\t.setColor([1.0, 0.0, 0.0]);\n *\n * // Attach the property to a Material.\n * node.setExtension('KHR_lights_punctual', light);\n * ```\n */\nexport class LightsPunctual extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new punctual Light property for use on a {@link Node}. */\n\tpublic createLight(name = ''): Light {\n\t\treturn new Light(this.document.getGraph(), name);\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\n\n\t\tconst rootDef = jsonDoc.json.extensions[NAME] as LightsPunctualRootDef;\n\t\tconst lightDefs = rootDef.lights || ([] as LightDef[]);\n\t\tconst lights = lightDefs.map((lightDef) => {\n\t\t\tconst light = this.createLight()\n\t\t\t\t.setName(lightDef.name || '')\n\t\t\t\t.setType(lightDef.type);\n\n\t\t\tif (lightDef.color !== undefined) light.setColor(lightDef.color);\n\t\t\tif (lightDef.intensity !== undefined) light.setIntensity(lightDef.intensity);\n\t\t\tif (lightDef.range !== undefined) light.setRange(lightDef.range);\n\n\t\t\tif (lightDef.innerConeAngle !== undefined) {\n\t\t\t\tlight.setInnerConeAngle(lightDef.innerConeAngle);\n\t\t\t}\n\t\t\tif (lightDef.outerConeAngle !== undefined) {\n\t\t\t\tlight.setOuterConeAngle(lightDef.outerConeAngle);\n\t\t\t}\n\n\t\t\treturn light;\n\t\t});\n\n\t\tjsonDoc.json.nodes!.forEach((nodeDef, nodeIndex) => {\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\n\t\t\tconst lightNodeDef = nodeDef.extensions[NAME] as LightsPunctualNodeDef;\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, lights[lightNodeDef.light]);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (this.properties.size === 0) return this;\n\n\t\tconst lightDefs = [];\n\t\tconst lightIndexMap = new Map<Light, number>();\n\n\t\tfor (const property of this.properties) {\n\t\t\tconst light = property as Light;\n\t\t\tconst lightDef = { type: light.getType() } as LightDef;\n\n\t\t\tif (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();\n\t\t\tif (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();\n\t\t\tif (light.getRange() != null) lightDef.range = light.getRange()!;\n\n\t\t\tif (light.getName()) lightDef['name'] = light.getName();\n\n\t\t\tif (light.getType() === Light.Type.SPOT) {\n\t\t\t\tlightDef['innerConeAngle'] = light.getInnerConeAngle();\n\t\t\t\tlightDef['outerConeAngle'] = light.getOuterConeAngle();\n\t\t\t}\n\n\t\t\tlightDefs.push(lightDef);\n\t\t\tlightIndexMap.set(light, lightDefs.length - 1);\n\t\t}\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listNodes()\n\t\t\t.forEach((node) => {\n\t\t\t\tconst light = node.getExtension<Light>(NAME);\n\t\t\t\tif (light) {\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\t\t\tnodeDef.extensions[NAME] = { light: lightIndexMap.get(light) };\n\t\t\t\t}\n\t\t\t});\n\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\n\t\tjsonDoc.json.extensions[NAME] = { lights: lightDefs };\n\n\t\treturn this;\n\t}\n}\n","import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\n\ninterface IClearcoat extends IProperty {\n\tclearcoatFactor: number;\n\tclearcoatTexture: Texture;\n\tclearcoatTextureInfo: TextureInfo;\n\n\tclearcoatRoughnessFactor: number;\n\tclearcoatRoughnessTexture: Texture;\n\tclearcoatRoughnessTextureInfo: TextureInfo;\n\n\tclearcoatNormalScale: number;\n\tclearcoatNormalTexture: Texture;\n\tclearcoatNormalTextureInfo: TextureInfo;\n}\n\nconst { R, G, B } = TextureChannel;\n\n/**\n * # Clearcoat\n *\n * Defines clear coat for a PBR material. See {@link MaterialsClearcoat}.\n */\nexport class Clearcoat extends ExtensionProperty<IClearcoat> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;\n\tpublic declare extensionName: typeof KHR_MATERIALS_CLEARCOAT;\n\tpublic declare propertyType: 'Clearcoat';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_CLEARCOAT;\n\t\tthis.propertyType = 'Clearcoat';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IClearcoat> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tclearcoatFactor: 0,\n\t\t\tclearcoatTexture: null,\n\t\t\tclearcoatTextureInfo: new TextureInfo(this.graph, 'clearcoatTextureInfo'),\n\n\t\t\tclearcoatRoughnessFactor: 0,\n\t\t\tclearcoatRoughnessTexture: null,\n\t\t\tclearcoatRoughnessTextureInfo: new TextureInfo(this.graph, 'clearcoatRoughnessTextureInfo'),\n\n\t\t\tclearcoatNormalScale: 1,\n\t\t\tclearcoatNormalTexture: null,\n\t\t\tclearcoatNormalTextureInfo: new TextureInfo(this.graph, 'clearcoatNormalTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat.\n\t */\n\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\n\tpublic getClearcoatFactor(): number {\n\t\treturn this.get('clearcoatFactor');\n\t}\n\n\t/** Clearcoat; linear multiplier. See {@link getClearcoatTexture}. */\n\tpublic setClearcoatFactor(factor: number): this {\n\t\treturn this.set('clearcoatFactor', factor);\n\t}\n\n\t/**\n\t * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount\n\t * [0-1] of coating over the surface of the material, which may have its own roughness and\n\t * normal map properties.\n\t */\n\tpublic getClearcoatTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatTexture') ? this.getRef('clearcoatTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat texture. See {@link getClearcoatTexture}. */\n\tpublic setClearcoatTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat roughness.\n\t */\n\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\n\tpublic getClearcoatRoughnessFactor(): number {\n\t\treturn this.get('clearcoatRoughnessFactor');\n\t}\n\n\t/** Clearcoat roughness; linear multiplier. See {@link getClearcoatRoughnessTexture}. */\n\tpublic setClearcoatRoughnessFactor(factor: number): this {\n\t\treturn this.set('clearcoatRoughnessFactor', factor);\n\t}\n\n\t/**\n\t * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic getClearcoatRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatRoughnessTexture') ? this.getRef('clearcoatRoughnessTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat roughness texture. See {@link getClearcoatRoughnessTexture}. */\n\tpublic setClearcoatRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatRoughnessTexture', texture, { channels: G });\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat normals.\n\t */\n\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\n\tpublic getClearcoatNormalScale(): number {\n\t\treturn this.get('clearcoatNormalScale');\n\t}\n\n\t/** Clearcoat normal scale. See {@link getClearcoatNormalTexture}. */\n\tpublic setClearcoatNormalScale(scale: number): this {\n\t\treturn this.set('clearcoatNormalScale', scale);\n\t}\n\n\t/**\n\t * Clearcoat normal map. Independent of the material base layer normal map.\n\t */\n\tpublic getClearcoatNormalTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatNormalTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat normal texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatNormalTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatNormalTexture') ? this.getRef('clearcoatNormalTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat normal texture. See {@link getClearcoatNormalTexture}. */\n\tpublic setClearcoatNormalTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatNormalTexture', texture, { channels: R | G | B });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants';\nimport { Clearcoat } from './clearcoat';\n\nconst NAME = KHR_MATERIALS_CLEARCOAT;\n\ninterface ClearcoatDef {\n\tclearcoatFactor?: number;\n\tclearcoatRoughnessFactor?: number;\n\tclearcoatTexture?: GLTF.ITextureInfo;\n\tclearcoatRoughnessTexture?: GLTF.ITextureInfo;\n\tclearcoatNormalTexture?: GLTF.IMaterialNormalTextureInfo;\n}\n\n/**\n * # MaterialsClearcoat\n *\n * [KHR_materials_clearcoat](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_clearcoat/)\n * defines a clear coating on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-clearcoat.png)\n *\n * > _**Figure:** Comparison of a carbon-fiber material without clearcoat (left) and with clearcoat\n * > (right). Source: [Filament](https://google.github.io/filament/Materials.html)._\n *\n * A clear coat is a common technique used in Physically-Based\n * Rendering for a protective layer applied to a base material.\n * Commonly used to represent car paint, carbon fiber, or thin lacquers.\n *\n * Properties:\n * - {@link Clearcoat}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsClearcoat, Clearcoat } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const clearcoatExtension = document.createExtension(MaterialsClearcoat);\n *\n * // Create Clearcoat property.\n * const clearcoat = clearcoatExtension.createClearcoat()\n *\t.setClearcoatFactor(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_clearcoat', clearcoat);\n * ```\n */\nexport class MaterialsClearcoat extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Clearcoat property for use on a {@link Material}. */\n\tpublic createClearcoat(): Clearcoat {\n\t\treturn new Clearcoat(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst clearcoat = this.createClearcoat();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, clearcoat);\n\n\t\t\t\tconst clearcoatDef = materialDef.extensions[NAME] as ClearcoatDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (clearcoatDef.clearcoatFactor !== undefined) {\n\t\t\t\t\tclearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessFactor !== undefined) {\n\t\t\t\t\tclearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (clearcoatDef.clearcoatTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatRoughnessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatNormalTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatNormalTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatNormalTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo()!, textureInfoDef);\n\t\t\t\t\tif (textureInfoDef.scale !== undefined) {\n\t\t\t\t\t\tclearcoat.setClearcoatNormalScale(textureInfoDef.scale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst clearcoat = material.getExtension<Clearcoat>(NAME);\n\t\t\t\tif (clearcoat) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst clearcoatDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tclearcoatFactor: clearcoat.getClearcoatFactor(),\n\t\t\t\t\t\tclearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor(),\n\t\t\t\t\t} as ClearcoatDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (clearcoat.getClearcoatTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (clearcoat.getClearcoatRoughnessTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatRoughnessTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatRoughnessTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (clearcoat.getClearcoatNormalTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatNormalTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatNormalTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t\tif (clearcoat.getClearcoatNormalScale() !== 1) {\n\t\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\n\ninterface IEmissiveStrength extends IProperty {\n\temissiveStrength: number;\n}\n\n/**\n * # EmissiveStrength\n *\n * Defines emissive strength for a PBR {@link Material}, allowing high-dynamic-range\n * (HDR) emissive materials. See {@link MaterialsEmissiveStrength}.\n */\nexport class EmissiveStrength extends ExtensionProperty<IEmissiveStrength> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\tpublic declare extensionName: typeof KHR_MATERIALS_EMISSIVE_STRENGTH;\n\tpublic declare propertyType: 'EmissiveStrength';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\t\tthis.propertyType = 'EmissiveStrength';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IEmissiveStrength> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { emissiveStrength: 1.0 });\n\t}\n\n\t/**********************************************************************************************\n\t * EmissiveStrength.\n\t */\n\n\t/** EmissiveStrength. */\n\tpublic getEmissiveStrength(): number {\n\t\treturn this.get('emissiveStrength');\n\t}\n\n\t/** EmissiveStrength. */\n\tpublic setEmissiveStrength(strength: number): this {\n\t\treturn this.set('emissiveStrength', strength);\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants';\nimport { EmissiveStrength } from './emissive-strength';\n\nconst NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\ninterface EmissiveStrengthDef {\n\temissiveStrength?: number;\n}\n\n/**\n * # MaterialsEmissiveStrength\n *\n * [KHR_materials_emissive_strength](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_emissive_strength/)\n * defines emissive strength and enables high-dynamic-range (HDR) emissive materials.\n *\n * [[include:UNRATIFIED_EXTENSIONS_NOTE.md]]\n *\n * The core glTF 2.0 material model includes {@link Material.setEmissiveFactor `emissiveFactor`}\n * and {@link Material.setEmissiveTexture `emissiveTexture`} to control the color and intensity\n * of the light being emitted by the material, clamped to the range [0.0, 1.0]. However, in\n * PBR environments with HDR reflections and lighting, stronger emission effects may be desirable.\n *\n * In this extension, a new {@link EmissiveStrength.setEmissiveStrength `emissiveStrength`} scalar\n * factor is supplied, which governs the upper limit of emissive strength per material and may be\n * given arbitrarily high values.\n *\n * For implementations where a physical light unit is needed, the units for the multiplicative\n * product of the emissive texture and factor are candela per square meter (cd / m2), sometimes\n * called _nits_. Many realtime rendering engines simplify this calculation by assuming that an\n * emissive factor of 1.0 results in a fully exposed pixel.\n *\n * Properties:\n * - {@link EmissiveStrength}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsEmissiveStrength, EmissiveStrength } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const emissiveStrengthExtension = document.createExtension(MaterialsEmissiveStrength);\n *\n * // Create EmissiveStrength property.\n * const emissiveStrength = emissiveStrengthExtension\n * \t.createEmissiveStrength().setEmissiveStrength(5.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_emissive_strength', emissiveStrength);\n * ```\n */\nexport class MaterialsEmissiveStrength extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new EmissiveStrength property for use on a {@link Material}. */\n\tpublic createEmissiveStrength(): EmissiveStrength {\n\t\treturn new EmissiveStrength(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst emissiveStrength = this.createEmissiveStrength();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, emissiveStrength);\n\n\t\t\t\tconst emissiveStrengthDef = materialDef.extensions[NAME] as EmissiveStrengthDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (emissiveStrengthDef.emissiveStrength !== undefined) {\n\t\t\t\t\temissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst emissiveStrength = material.getExtension<EmissiveStrength>(NAME);\n\t\t\t\tif (emissiveStrength) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\temissiveStrength: emissiveStrength.getEmissiveStrength(),\n\t\t\t\t\t} as EmissiveStrengthDef;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IOR } from '../constants';\n\ninterface IIOR extends IProperty {\n\tior: number;\n}\n\n/**\n * # IOR\n *\n * Defines index of refraction for a PBR {@link Material}. See {@link MaterialsIOR}.\n */\nexport class IOR extends ExtensionProperty<IIOR> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IOR;\n\tpublic declare extensionName: typeof KHR_MATERIALS_IOR;\n\tpublic declare propertyType: 'IOR';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_IOR;\n\t\tthis.propertyType = 'IOR';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IIOR> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { ior: 0 });\n\t}\n\n\t/**********************************************************************************************\n\t * IOR.\n\t */\n\n\t/** IOR. */\n\tpublic getIOR(): number {\n\t\treturn this.get('ior');\n\t}\n\n\t/** IOR. */\n\tpublic setIOR(ior: number): this {\n\t\treturn this.set('ior', ior);\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IOR } from '../constants';\nimport { IOR } from './ior';\n\nconst NAME = KHR_MATERIALS_IOR;\n\ninterface IORDef {\n\tior?: number;\n}\n\n/**\n * # MaterialsIOR\n *\n * [KHR_materials_ior](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_ior/)\n * defines index of refraction on a glTF PBR material.\n *\n * The dielectric BRDF of the metallic-roughness material in glTF uses a fixed value of 1.5 for the\n * index of refraction. This is a good fit for many plastics and glass, but not for other materials\n * like water or asphalt, sapphire or diamond. `KHR_materials_ior` allows users to set the index of\n * refraction to a certain value.\n *\n * Properties:\n * - {@link IOR}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsIOR, IOR } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const iorExtension = document.createExtension(MaterialsIOR);\n *\n * // Create IOR property.\n * const ior = iorExtension.createIOR().setIOR(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_ior', ior);\n * ```\n */\nexport class MaterialsIOR extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new IOR property for use on a {@link Material}. */\n\tpublic createIOR(): IOR {\n\t\treturn new IOR(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst ior = this.createIOR();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, ior);\n\n\t\t\t\tconst iorDef = materialDef.extensions[NAME] as IORDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (iorDef.ior !== undefined) {\n\t\t\t\t\tior.setIOR(iorDef.ior);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst ior = material.getExtension<IOR>(NAME);\n\t\t\t\tif (ior) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\tior: ior.getIOR(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\n\ninterface IPBRSpecularGlossiness extends IProperty {\n\tdiffuseFactor: vec4;\n\tdiffuseTexture: Texture;\n\tdiffuseTextureInfo: TextureInfo;\n\tspecularFactor: vec3;\n\tglossinessFactor: number;\n\tspecularGlossinessTexture: Texture;\n\tspecularGlossinessTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # PBRSpecularGlossiness\n *\n * Converts a {@link Material} to a spec/gloss workflow. See {@link MaterialsPBRSpecularGlossiness}.\n */\nexport class PBRSpecularGlossiness extends ExtensionProperty<IPBRSpecularGlossiness> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\tpublic declare propertyType: 'PBRSpecularGlossiness';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\t\tthis.propertyType = 'PBRSpecularGlossiness';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IPBRSpecularGlossiness> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tdiffuseFactor: [1.0, 1.0, 1.0, 1.0] as vec4,\n\t\t\tdiffuseTexture: null,\n\t\t\tdiffuseTextureInfo: new TextureInfo(this.graph, 'diffuseTextureInfo'),\n\t\t\tspecularFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tglossinessFactor: 1.0,\n\t\t\tspecularGlossinessTexture: null,\n\t\t\tspecularGlossinessTextureInfo: new TextureInfo(this.graph, 'specularGlossinessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Diffuse.\n\t */\n\n\t/** Diffuse; linear multiplier. See {@link getDiffuseTexture}. */\n\tpublic getDiffuseFactor(): vec4 {\n\t\treturn this.get('diffuseFactor');\n\t}\n\n\t/** Diffuse; linear multiplier. See {@link getDiffuseTexture}. */\n\tpublic setDiffuseFactor(factor: vec4): this {\n\t\treturn this.set('diffuseFactor', factor);\n\t}\n\n\t/** Diffuse; hex color in sRGB colorspace. */\n\tpublic getDiffuseHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getDiffuseFactor());\n\t}\n\n\t/** Diffuse; hex color in sRGB colorspace. */\n\tpublic setDiffuseHex(hex: number): this {\n\t\tconst factor = this.getDiffuseFactor().slice() as vec4;\n\t\treturn this.setDiffuseFactor(ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Diffuse texture; linear multiplier. Alternative to baseColorTexture used within the\n\t * spec/gloss PBR workflow.\n\t */\n\tpublic getDiffuseTexture(): Texture | null {\n\t\treturn this.getRef('diffuseTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its diffuse texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getDiffuseTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('diffuseTexture') ? this.getRef('diffuseTextureInfo') : null;\n\t}\n\n\t/** Sets diffuse texture. See {@link getDiffuseTexture}. */\n\tpublic setDiffuseTexture(texture: Texture | null): this {\n\t\treturn this.setRef('diffuseTexture', texture, { channels: R | G | B | A });\n\t}\n\n\t/**********************************************************************************************\n\t * Specular.\n\t */\n\n\t/** Specular; linear multiplier. */\n\tpublic getSpecularFactor(): vec3 {\n\t\treturn this.get('specularFactor');\n\t}\n\n\t/** Specular; linear multiplier. */\n\tpublic setSpecularFactor(factor: vec3): this {\n\t\treturn this.set('specularFactor', factor);\n\t}\n\n\t/**********************************************************************************************\n\t * Glossiness.\n\t */\n\n\t/** Glossiness; linear multiplier. */\n\tpublic getGlossinessFactor(): number {\n\t\treturn this.get('glossinessFactor');\n\t}\n\n\t/** Glossiness; linear multiplier. */\n\tpublic setGlossinessFactor(factor: number): this {\n\t\treturn this.set('glossinessFactor', factor);\n\t}\n\n\t/**********************************************************************************************\n\t * Specular/Glossiness.\n\t */\n\n\t/** Spec/gloss texture; linear multiplier. */\n\tpublic getSpecularGlossinessTexture(): Texture | null {\n\t\treturn this.getRef('specularGlossinessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularGlossinessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularGlossinessTexture') ? this.getRef('specularGlossinessTextureInfo') : null;\n\t}\n\n\t/** Spec/gloss texture; linear multiplier. */\n\tpublic setSpecularGlossinessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularGlossinessTexture', texture, { channels: R | G | B | A });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, vec4 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants';\nimport { PBRSpecularGlossiness } from './pbr-specular-glossiness';\n\nconst NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\ninterface SpecularGlossinessDef {\n\tdiffuseFactor?: vec4;\n\tspecularFactor: vec3;\n\tglossinessFactor: number;\n\tdiffuseTexture?: GLTF.ITextureInfo;\n\tspecularGlossinessTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsPBRSpecularGlossiness\n *\n * [`KHR_materials_pbrSpecularGlossiness`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/)\n * converts a PBR material from the default metal/rough workflow to a spec/gloss workflow.\n *\n * > _**NOTICE:** The spec/gloss workflow does _not_ support other PBR extensions such as clearcoat,\n * > transmission, IOR, etc. For the complete PBR feature set and specular data, use the\n * > {@link MaterialsSpecular} extension instead, which provides specular data within a metal/rough\n * > workflow._\n *\n * ![Illustration](/media/extensions/khr-material-pbr-specular-glossiness.png)\n *\n * > _**Figure:** Components of a PBR spec/gloss material. Source: Khronos Group._\n *\n * Properties:\n * - {@link PBRSpecularGlossiness}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsPBRSpecularGlossiness } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const specGlossExtension = document.createExtension(MaterialsPBRSpecularGlossiness);\n *\n * // Create a PBRSpecularGlossiness property.\n * const specGloss = specGlossExtension.createPBRSpecularGlossiness()\n * \t.setSpecularFactor(1.0);\n *\n * // // Assign to a Material.\n * material.setExtension('KHR_materials_pbrSpecularGlossiness', specGloss);\n * ```\n */\nexport class MaterialsPBRSpecularGlossiness extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */\n\tpublic createPBRSpecularGlossiness(): PBRSpecularGlossiness {\n\t\treturn new PBRSpecularGlossiness(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst specGloss = this.createPBRSpecularGlossiness();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specGloss);\n\n\t\t\t\tconst specGlossDef = materialDef.extensions[NAME] as SpecularGlossinessDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (specGlossDef.diffuseFactor !== undefined) {\n\t\t\t\t\tspecGloss.setDiffuseFactor(specGlossDef.diffuseFactor);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.specularFactor !== undefined) {\n\t\t\t\t\tspecGloss.setSpecularFactor(specGlossDef.specularFactor);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.glossinessFactor !== undefined) {\n\t\t\t\t\tspecGloss.setGlossinessFactor(specGlossDef.glossinessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (specGlossDef.diffuseTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specGlossDef.diffuseTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecGloss.setDiffuseTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getDiffuseTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.specularGlossinessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specGlossDef.specularGlossinessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecGloss.setSpecularGlossinessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>(NAME);\n\t\t\t\tif (specGloss) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst specGlossDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tdiffuseFactor: specGloss.getDiffuseFactor(),\n\t\t\t\t\t\tspecularFactor: specGloss.getSpecularFactor(),\n\t\t\t\t\t\tglossinessFactor: specGloss.getGlossinessFactor(),\n\t\t\t\t\t} as SpecularGlossinessDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (specGloss.getDiffuseTexture()) {\n\t\t\t\t\t\tconst texture = specGloss.getDiffuseTexture()!;\n\t\t\t\t\t\tconst textureInfo = specGloss.getDiffuseTextureInfo()!;\n\t\t\t\t\t\tspecGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (specGloss.getSpecularGlossinessTexture()) {\n\t\t\t\t\t\tconst texture = specGloss.getSpecularGlossinessTexture()!;\n\t\t\t\t\t\tconst textureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\t\t\tspecGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_SHEEN } from '../constants';\n\ninterface ISheen extends IProperty {\n\tsheenColorFactor: vec3;\n\tsheenColorTexture: Texture;\n\tsheenColorTextureInfo: TextureInfo;\n\tsheenRoughnessFactor: number;\n\tsheenRoughnessTexture: Texture;\n\tsheenRoughnessTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # Sheen\n *\n * Defines sheen on a PBR {@link Material}. See {@link MaterialsSheen}.\n */\nexport class Sheen extends ExtensionProperty<ISheen> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SHEEN;\n\tpublic declare extensionName: typeof KHR_MATERIALS_SHEEN;\n\tpublic declare propertyType: 'Sheen';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_SHEEN;\n\t\tthis.propertyType = 'Sheen';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ISheen> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tsheenColorFactor: [0.0, 0.0, 0.0] as vec3,\n\t\t\tsheenColorTexture: null,\n\t\t\tsheenColorTextureInfo: new TextureInfo(this.graph, 'sheenColorTextureInfo'),\n\t\t\tsheenRoughnessFactor: 0.0,\n\t\t\tsheenRoughnessTexture: null,\n\t\t\tsheenRoughnessTextureInfo: new TextureInfo(this.graph, 'sheenRoughnessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Sheen color.\n\t */\n\n\t/** Sheen; linear multiplier. */\n\tpublic getSheenColorFactor(): vec3 {\n\t\treturn this.get('sheenColorFactor');\n\t}\n\n\t/** Sheen; hex color in sRGB colorspace. */\n\tpublic getSheenColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getSheenColorFactor());\n\t}\n\n\t/** Sheen; linear multiplier. */\n\tpublic setSheenColorFactor(factor: vec3): this {\n\t\treturn this.set('sheenColorFactor', factor);\n\t}\n\n\t/** Sheen; hex color in sRGB colorspace. */\n\tpublic setSheenColorHex(hex: number): this {\n\t\tconst factor = this.getSheenColorFactor().slice() as vec3;\n\t\treturn this.set('sheenColorFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Sheen color texture, in sRGB colorspace.\n\t */\n\tpublic getSheenColorTexture(): Texture | null {\n\t\treturn this.getRef('sheenColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its sheen color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSheenColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('sheenColorTexture') ? this.getRef('sheenColorTextureInfo') : null;\n\t}\n\n\t/** Sets sheen color texture. See {@link getSheenColorTexture}. */\n\tpublic setSheenColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('sheenColorTexture', texture, { channels: R | G | B });\n\t}\n\n\t/**********************************************************************************************\n\t * Sheen roughness.\n\t */\n\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\n\tpublic getSheenRoughnessFactor(): number {\n\t\treturn this.get('sheenRoughnessFactor');\n\t}\n\n\t/** Sheen roughness; linear multiplier. See {@link getSheenRoughnessTexture}. */\n\tpublic setSheenRoughnessFactor(factor: number): this {\n\t\treturn this.set('sheenRoughnessFactor', factor);\n\t}\n\n\t/**\n\t * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic getSheenRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('sheenRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its sheen roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getSheenRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('sheenRoughnessTexture') ? this.getRef('sheenRoughnessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Sets sheen roughness texture.  The `a` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic setSheenRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('sheenRoughnessTexture', texture, { channels: A });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_SHEEN } from '../constants';\nimport { Sheen } from './sheen';\n\nconst NAME = KHR_MATERIALS_SHEEN;\n\ninterface SheenDef {\n\tsheenColorFactor?: vec3;\n\tsheenRoughnessFactor?: number;\n\tsheenColorTexture?: GLTF.ITextureInfo;\n\tsheenRoughnessTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsSheen\n *\n * [`KHR_materials_sheen`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen/)\n * defines a velvet-like sheen layered on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-sheen.png)\n *\n * > _**Figure:** A cushion, showing high material roughness and low sheen roughness. Soft\n * > highlights at edges of the material show backscattering from microfibers. Source: Khronos\n * > Group._\n *\n * A sheen layer is a common technique used in Physically-Based Rendering to represent\n * cloth and fabric materials.\n *\n * Properties:\n * - {@link Sheen}\n *\n * ### Example\n *\n * The `MaterialsSheen` class provides a single {@link ExtensionProperty} type, `Sheen`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsSheen, Sheen } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const sheenExtension = document.createExtension(MaterialsSheen);\n *\n * // Create a Sheen property.\n * const sheen = sheenExtension.createSheen()\n * \t.setSheenColorFactor([1.0, 1.0, 1.0]);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_sheen', sheen);\n * ```\n */\nexport class MaterialsSheen extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Sheen property for use on a {@link Material}. */\n\tpublic createSheen(): Sheen {\n\t\treturn new Sheen(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst sheen = this.createSheen();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, sheen);\n\n\t\t\t\tconst sheenDef = materialDef.extensions[NAME] as SheenDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (sheenDef.sheenColorFactor !== undefined) {\n\t\t\t\t\tsheen.setSheenColorFactor(sheenDef.sheenColorFactor);\n\t\t\t\t}\n\t\t\t\tif (sheenDef.sheenRoughnessFactor !== undefined) {\n\t\t\t\t\tsheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (sheenDef.sheenColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tsheen.setSheenColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (sheenDef.sheenRoughnessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenRoughnessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tsheen.setSheenRoughnessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst sheen = material.getExtension<Sheen>(NAME);\n\t\t\t\tif (sheen) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst sheenDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tsheenColorFactor: sheen.getSheenColorFactor(),\n\t\t\t\t\t\tsheenRoughnessFactor: sheen.getSheenRoughnessFactor(),\n\t\t\t\t\t} as SheenDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (sheen.getSheenColorTexture()) {\n\t\t\t\t\t\tconst texture = sheen.getSheenColorTexture()!;\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenColorTextureInfo()!;\n\t\t\t\t\t\tsheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (sheen.getSheenRoughnessTexture()) {\n\t\t\t\t\t\tconst texture = sheen.getSheenRoughnessTexture()!;\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenRoughnessTextureInfo()!;\n\t\t\t\t\t\tsheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\n\ninterface ISpecular extends IProperty {\n\tspecularFactor: number;\n\tspecularTexture: Texture;\n\tspecularTextureInfo: TextureInfo;\n\tspecularColorFactor: vec3;\n\tspecularColorTexture: Texture;\n\tspecularColorTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * # Specular\n *\n * Defines specular reflectivity on a PBR {@link Material}. See {@link MaterialsSpecular}.\n */\nexport class Specular extends ExtensionProperty<ISpecular> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SPECULAR;\n\tpublic declare extensionName: typeof KHR_MATERIALS_SPECULAR;\n\tpublic declare propertyType: 'Specular';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_SPECULAR;\n\t\tthis.propertyType = 'Specular';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ISpecular> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tspecularFactor: 1.0,\n\t\t\tspecularTexture: null,\n\t\t\tspecularTextureInfo: new TextureInfo(this.graph, 'specularTextureInfo'),\n\t\t\tspecularColorFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tspecularColorTexture: null,\n\t\t\tspecularColorTextureInfo: new TextureInfo(this.graph, 'specularColorTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Specular.\n\t */\n\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\n\tpublic getSpecularFactor(): number {\n\t\treturn this.get('specularFactor');\n\t}\n\n\t/** Specular; linear multiplier. See {@link getSpecularTexture}. */\n\tpublic setSpecularFactor(factor: number): this {\n\t\treturn this.set('specularFactor', factor);\n\t}\n\n\t/** Specular color; components in linear space. See {@link getSpecularTexture}. */\n\tpublic getSpecularColorFactor(): vec3 {\n\t\treturn this.get('specularColorFactor');\n\t}\n\n\t/** Specular color; components in linear space. See {@link getSpecularTexture}. */\n\tpublic setSpecularColorFactor(factor: vec3): this {\n\t\treturn this.set('specularColorFactor', factor);\n\t}\n\n\t/** Specular color; hexadecimal in sRGB colorspace. See {@link getSpecularTexture} */\n\tpublic getSpecularColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getSpecularColorFactor());\n\t}\n\n\t/** Specular color; hexadecimal in sRGB colorspace. See {@link getSpecularTexture} */\n\tpublic setSpecularColorHex(hex: number): this {\n\t\tconst factor = this.getSpecularColorFactor().slice() as vec3;\n\t\treturn this.set('specularColorFactor', ColorUtils.hexToFactor(hex, factor));\n\t}\n\n\t/**\n\t * Specular texture; linear multiplier. Configures the strength of the specular reflection in\n\t * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure\n\t * diffuse material.\n\t *\n\t * Only the alpha (A) channel is used for specular strength, but this texture may optionally\n\t * be packed with specular color (RGB) into a single texture.\n\t */\n\tpublic getSpecularTexture(): Texture | null {\n\t\treturn this.getRef('specularTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its specular texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularTexture') ? this.getRef('specularTextureInfo') : null;\n\t}\n\n\t/** Sets specular texture. See {@link getSpecularTexture}. */\n\tpublic setSpecularTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularTexture', texture, { channels: A });\n\t}\n\n\t/**\n\t * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection\n\t * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\n\t *\n\t * Only RGB channels are used here, but this texture may optionally be packed with a specular\n\t * factor (A) into a single texture.\n\t */\n\tpublic getSpecularColorTexture(): Texture | null {\n\t\treturn this.getRef('specularColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its specular color texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularColorTexture') ? this.getRef('specularColorTextureInfo') : null;\n\t}\n\n\t/** Sets specular color texture. See {@link getSpecularColorTexture}. */\n\tpublic setSpecularColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularColorTexture', texture, { channels: R | G | B });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\nimport { KHR_MATERIALS_SPECULAR } from '../constants';\nimport { Specular } from './specular';\n\nconst NAME = KHR_MATERIALS_SPECULAR;\n\ninterface SpecularDef {\n\tspecularFactor?: number;\n\tspecularColorFactor?: vec3;\n\tspecularTexture?: GLTF.ITextureInfo;\n\tspecularColorTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsSpecular\n *\n * [`KHR_materials_specular`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_specular/)\n * adjusts the strength of the specular reflection in the dielectric BRDF.\n *\n * MaterialsSpecular is a better alternative to the older\n * {@link MaterialsPBRSpecularGlossiness KHR_materials_pbrSpecularGlossiness} extension, and\n * provides specular information while remaining within a metal/rough PBR workflow. A\n * value of zero disables the specular reflection, resulting in a pure diffuse material.\n *\n * Properties:\n * - {@link Specular}\n *\n * ### Example\n *\n * The `MaterialsSpecular` class provides a single {@link ExtensionProperty} type, `Specular`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsSpecular, Specular } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const specularExtension = document.createExtension(MaterialsSpecular);\n *\n * // Create a Specular property.\n * const specular = specularExtension.createSpecular()\n * \t.setSpecularFactor(1.0);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_specular', specular);\n * ```\n */\nexport class MaterialsSpecular extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Specular property for use on a {@link Material}. */\n\tpublic createSpecular(): Specular {\n\t\treturn new Specular(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst specular = this.createSpecular();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specular);\n\n\t\t\t\tconst specularDef = materialDef.extensions[NAME] as SpecularDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (specularDef.specularFactor !== undefined) {\n\t\t\t\t\tspecular.setSpecularFactor(specularDef.specularFactor);\n\t\t\t\t}\n\t\t\t\tif (specularDef.specularColorFactor !== undefined) {\n\t\t\t\t\tspecular.setSpecularColorFactor(specularDef.specularColorFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (specularDef.specularTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specularDef.specularTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecular.setSpecularTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (specularDef.specularColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specularDef.specularColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecular.setSpecularColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst specular = material.getExtension<Specular>(NAME);\n\t\t\t\tif (specular) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst specularDef = (materialDef.extensions[NAME] = {} as SpecularDef);\n\n\t\t\t\t\tif (specular.getSpecularFactor() !== 1) {\n\t\t\t\t\t\tspecularDef.specularFactor = specular.getSpecularFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {\n\t\t\t\t\t\tspecularDef.specularColorFactor = specular.getSpecularColorFactor();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (specular.getSpecularTexture()) {\n\t\t\t\t\t\tconst texture = specular.getSpecularTexture()!;\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularTextureInfo()!;\n\t\t\t\t\t\tspecularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (specular.getSpecularColorTexture()) {\n\t\t\t\t\t\tconst texture = specular.getSpecularColorTexture()!;\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularColorTextureInfo()!;\n\t\t\t\t\t\tspecularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\n\ninterface ITransmission extends IProperty {\n\ttransmissionFactor: number;\n\ttransmissionTexture: Texture;\n\ttransmissionTextureInfo: TextureInfo;\n}\n\nconst { R } = TextureChannel;\n\n/**\n * # Transmission\n *\n * Defines optical transmission on a PBR {@link Material}. See {@link MaterialsTransmission}.\n */\nexport class Transmission extends ExtensionProperty<ITransmission> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;\n\tpublic declare extensionName: typeof KHR_MATERIALS_TRANSMISSION;\n\tpublic declare propertyType: 'Transmission';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_TRANSMISSION;\n\t\tthis.propertyType = 'Transmission';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ITransmission> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\ttransmissionFactor: 0.0,\n\t\t\ttransmissionTexture: null,\n\t\t\ttransmissionTextureInfo: new TextureInfo(this.graph, 'transmissionTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Transmission.\n\t */\n\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\n\tpublic getTransmissionFactor(): number {\n\t\treturn this.get('transmissionFactor');\n\t}\n\n\t/** Transmission; linear multiplier. See {@link getTransmissionTexture}. */\n\tpublic setTransmissionFactor(factor: number): this {\n\t\treturn this.set('transmissionFactor', factor);\n\t}\n\n\t/**\n\t * Transmission texture; linear multiplier. The `r` channel of this texture specifies\n\t * transmission [0-1] of the material's surface. By default this is a thin transparency\n\t * effect, but volume effects (refraction, subsurface scattering) may be introduced with the\n\t * addition of the `KHR_materials_volume` extension.\n\t */\n\tpublic getTransmissionTexture(): Texture | null {\n\t\treturn this.getRef('transmissionTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its transmission texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getTransmissionTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('transmissionTexture') ? this.getRef('transmissionTextureInfo') : null;\n\t}\n\n\t/** Sets transmission texture. See {@link getTransmissionTexture}. */\n\tpublic setTransmissionTexture(texture: Texture | null): this {\n\t\treturn this.setRef('transmissionTexture', texture, { channels: R });\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants';\nimport { Transmission } from './transmission';\n\nconst NAME = KHR_MATERIALS_TRANSMISSION;\n\ninterface TransmissionDef {\n\ttransmissionFactor?: number;\n\ttransmissionTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * # MaterialsTransmission\n *\n * [`KHR_materials_transmission`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_transmission/)\n * provides a common type of optical transparency: infinitely-thin materials with no refraction,\n * scattering, or dispersion.\n *\n * While default PBR materials using alpha blending become invisible as their opacity approaches\n * zero, a transmissive material continues to reflect light in a glass-like manner, even at low\n * transmission values. When combined with {@link MaterialsVolume}, transmission may be used for\n * thicker materials and refractive effects.\n *\n * Properties:\n * - {@link Transmission}\n *\n * ### Example\n *\n * The `MaterialsTransmission` class provides a single {@link ExtensionProperty} type,\n * `Transmission`, which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsTransmission, Transmission } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const transmissionExtension = document.createExtension(MaterialsTransmission);\n *\n * // Create a Transmission property.\n * const transmission = transmissionExtension.createTransmission()\n * \t.setTransmissionFactor(1.0);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_transmission', transmission);\n * ```\n */\nexport class MaterialsTransmission extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Transmission property for use on a {@link Material}. */\n\tpublic createTransmission(): Transmission {\n\t\treturn new Transmission(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst transmission = this.createTransmission();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, transmission);\n\n\t\t\t\tconst transmissionDef = materialDef.extensions[NAME] as TransmissionDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (transmissionDef.transmissionFactor !== undefined) {\n\t\t\t\t\ttransmission.setTransmissionFactor(transmissionDef.transmissionFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (transmissionDef.transmissionTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = transmissionDef.transmissionTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\ttransmission.setTransmissionTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(transmission.getTransmissionTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst transmission = material.getExtension<Transmission>(NAME);\n\t\t\t\tif (transmission) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst transmissionDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\ttransmissionFactor: transmission.getTransmissionFactor(),\n\t\t\t\t\t} as TransmissionDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (transmission.getTransmissionTexture()) {\n\t\t\t\t\t\tconst texture = transmission.getTransmissionTexture()!;\n\t\t\t\t\t\tconst textureInfo = transmission.getTransmissionTextureInfo()!;\n\t\t\t\t\t\ttransmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty } from '@gltf-transform/core';\nimport { PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_UNLIT } from '../constants';\n\n/**\n * # Unlit\n *\n * Converts a PBR {@link Material} to an unlit shading model. See {@link MaterialsUnlit}.\n */\nexport class Unlit extends ExtensionProperty {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_UNLIT;\n\tpublic declare extensionName: typeof KHR_MATERIALS_UNLIT;\n\tpublic declare propertyType: 'Unlit';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_UNLIT;\n\t\tthis.propertyType = 'Unlit';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_UNLIT } from '../constants';\nimport { Unlit } from './unlit';\n\nconst NAME = KHR_MATERIALS_UNLIT;\n\n/**\n * # MaterialsUnlit\n *\n * [`KHR_materials_unlit`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_unlit/)\n * defines an unlit shading model for use in glTF 2.0 materials.\n *\n * ![Illustration](/media/extensions/khr-materials-unlit.png)\n *\n * > _**Figure:** Unlit materials are useful for flat shading, stylized effects, and for improving\n * > performance on mobile devices. Source: [Model by Hayden VanEarden](https://sketchfab.com/3d-models/summertime-kirby-c5711316103a4d67a62c34cfe8710938)._\n *\n * Unlit (also \"Shadeless\" or \"Constant\") materials provide a simple alternative to the Physically\n * Based Rendering (PBR) shading models provided by the core specification. Unlit materials are\n * often useful for cheaper rendering on performance-contrained devices, e.g. mobile phones.\n * Additionally, unlit materials can be very useful in achieving stylized, non-photo-realistic\n * effects like hand painted illustrative styles or baked toon shaders.\n *\n * Properties:\n * - {@link Unlit}\n *\n * ### Example\n *\n * The `MaterialsUnlit` class provides a single {@link ExtensionProperty} type, `Unlit`, which may\n * be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsUnlit, Unlit } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const unlitExtension = document.createExtension(MaterialsUnlit);\n *\n * // Create an Unlit property.\n * const unlit = unlitExtension.createUnlit();\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_unlit', unlit);\n * ```\n */\nexport class MaterialsUnlit extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Unlit property for use on a {@link Material}. */\n\tpublic createUnlit(): Unlit {\n\t\treturn new Unlit(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst materialDefs = context.jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, this.createUnlit());\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tif (material.getExtension<Unlit>(NAME)) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\t\t\t\tmaterialDef.extensions[NAME] = {};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Material, Nullable } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport { Variant } from './variant';\n\ninterface IMapping extends IProperty {\n\tmaterial: Material;\n\tvariants: Variant[];\n}\n\n/**\n * # Mapping\n *\n * Maps {@link Variant}s to {@link Material}s. See {@link MaterialsVariants}.\n */\nexport class Mapping extends ExtensionProperty<IMapping> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'Mapping';\n\tpublic declare parentTypes: ['MappingList'];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'Mapping';\n\t\tthis.parentTypes = ['MappingList'];\n\t}\n\n\tprotected getDefaults(): Nullable<IMapping> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { material: null, variants: [] });\n\t}\n\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n\tpublic getMaterial(): Material | null {\n\t\treturn this.getRef('material');\n\t}\n\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n\tpublic setMaterial(material: Material | null): this {\n\t\treturn this.setRef('material', material);\n\t}\n\n\t/** Adds a {@link Variant} to this mapping. */\n\tpublic addVariant(variant: Variant): this {\n\t\treturn this.addRef('variants', variant);\n\t}\n\n\t/** Removes a {@link Variant} from this mapping. */\n\tpublic removeVariant(variant: Variant): this {\n\t\treturn this.removeRef('variants', variant);\n\t}\n\n\t/** Lists {@link Variant}s in this mapping. */\n\tpublic listVariants(): Variant[] {\n\t\treturn this.listRefs('variants');\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport { Mapping } from './mapping';\n\ninterface IMappingList extends IProperty {\n\tmappings: Mapping[];\n}\n\n/**\n * # MappingList\n *\n * List of material variant {@link Mapping}s. See {@link MaterialsVariants}.\n */\nexport class MappingList extends ExtensionProperty<IMappingList> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'MappingList';\n\tpublic declare parentTypes: [PropertyType.PRIMITIVE];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'MappingList';\n\t\tthis.parentTypes = [PropertyType.PRIMITIVE];\n\t}\n\n\tprotected getDefaults(): Nullable<IMappingList> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { mappings: [] });\n\t}\n\n\t/** Adds a {@link Mapping} to this mapping. */\n\tpublic addMapping(mapping: Mapping): this {\n\t\treturn this.addRef('mappings', mapping);\n\t}\n\n\t/** Removes a {@link Mapping} from the list for this {@link Primitive}. */\n\tpublic removeMapping(mapping: Mapping): this {\n\t\treturn this.removeRef('mappings', mapping);\n\t}\n\n\t/** Lists {@link Mapping}s in this {@link Primitive}. */\n\tpublic listMappings(): Mapping[] {\n\t\treturn this.listRefs('mappings');\n\t}\n}\n","import { ExtensionProperty } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\n\n/**\n * # Variant\n *\n * Defines a variant of a {@link Material}. See {@link MaterialsVariants}.\n */\nexport class Variant extends ExtensionProperty {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'Variant';\n\tpublic declare parentTypes: ['MappingList'];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'Variant';\n\t\tthis.parentTypes = ['MappingList'];\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants';\nimport { Mapping } from './mapping';\nimport { MappingList } from './mapping-list';\nimport { Variant } from './variant';\n\nconst NAME = KHR_MATERIALS_VARIANTS;\n\ninterface VariantsRootDef {\n\tvariants: VariantDef[];\n}\n\ninterface VariantDef {\n\tname?: string;\n}\n\ninterface VariantPrimDef {\n\tmappings: VariantMappingDef[];\n}\n\ninterface VariantMappingDef {\n\tmaterial: number;\n\tvariants: number[];\n}\n\n/**\n * # MaterialsVariants\n *\n * [`KHR_materials_variants`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants/)\n * defines alternate {@link Material} states for any {@link Primitive} in the scene.\n *\n * ![Illustration](/media/extensions/khr-materials-variants.png)\n *\n * > _**Figure:** A sneaker, in three material variants. Source: Khronos Group._\n *\n * Uses include product configurators, night/day states, healthy/damaged states, etc. The\n * `MaterialsVariants` class provides three {@link ExtensionProperty} types: `Variant`, `Mapping`,\n * and `MappingList`. When attached to {@link Primitive} properties, these offer flexible ways of\n * defining the variants available to an application. Triggering a variant is out of scope of this\n * extension, but could be handled in the application with a UI dropdown, particular game states,\n * and so on.\n *\n * Mesh geometry cannot be changed by this extension, although another extension\n * (tentative: `KHR_mesh_variants`) is under consideration by the Khronos Group, for that purpose.\n *\n * Properties:\n * - {@link Variant}\n * - {@link Mapping}\n * - {@link MappingList}\n *\n * ### Example\n *\n * ```typescript\n * import { MaterialsVariants } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const variantExtension = document.createExtension(MaterialsVariants);\n *\n * // Create some Variant states.\n * const healthyVariant = variantExtension.createVariant('Healthy');\n * const damagedVariant = variantExtension.createVariant('Damaged');\n *\n * // Create mappings from a Variant state to a Material.\n * const healthyMapping = variantExtension.createMapping()\n * \t.addVariant(healthyVariant)\n * \t.setMaterial(healthyMat);\n * const damagedMapping = variantExtension.createMapping()\n * \t.addVariant(damagedVariant)\n * \t.setMaterial(damagedMat);\n *\n * // Attach the mappings to a Primitive.\n * primitive.setExtension(\n * \t'KHR_materials_variants',\n * \tvariantExtension.createMappingList()\n * \t\t.addMapping(healthyMapping)\n * \t\t.addMapping(damagedMapping)\n * );\n * ```\n *\n * A few notes about this extension:\n *\n * 1. Viewers that don't recognized this extension will show the default material for each primitive\n * \t instead, so assign that material accordingly. This material can be — but doesn't have to be —\n * \t associated with one of the available variants.\n * 2. Mappings can list multiple Variants. In that case, the first Mapping containing an active\n * \t Variant will be chosen by the viewer.\n * 3. Variant names are how these states are identified, so choose informative names.\n * 4. When writing the file to an unpacked `.gltf`, instead of an embedded `.glb`, viewers will have\n * \t the option of downloading only textures associated with the default state, and lazy-loading\n * \t any textures for inactive Variants only when they are needed.\n */\nexport class MaterialsVariants extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new MappingList property. */\n\tpublic createMappingList(): MappingList {\n\t\treturn new MappingList(this.document.getGraph());\n\t}\n\n\t/** Creates a new Variant property. */\n\tpublic createVariant(name = ''): Variant {\n\t\treturn new Variant(this.document.getGraph(), name);\n\t}\n\n\t/** Creates a new Mapping property. */\n\tpublic createMapping(): Mapping {\n\t\treturn new Mapping(this.document.getGraph());\n\t}\n\n\t/** Lists all Variants on the current Document. */\n\tpublic listVariants(): Variant[] {\n\t\treturn Array.from(this.properties).filter((prop) => prop instanceof Variant) as Variant[];\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\n\n\t\t// Read all top-level variant names.\n\t\tconst variantsRootDef = jsonDoc.json.extensions[NAME] as VariantsRootDef;\n\t\tconst variantDefs = variantsRootDef.variants || [];\n\t\tconst variants = variantDefs.map((variantDef) => this.createVariant().setName(variantDef.name || ''));\n\n\t\t// For each mesh primitive, read its material/variant mappings.\n\t\tconst meshDefs = jsonDoc.json.meshes || [];\n\t\tmeshDefs.forEach((meshDef, meshIndex) => {\n\t\t\tconst mesh = context.meshes[meshIndex];\n\t\t\tconst primDefs = meshDef.primitives || [];\n\n\t\t\tprimDefs.forEach((primDef, primIndex) => {\n\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst mappingList = this.createMappingList();\n\n\t\t\t\tconst variantPrimDef = primDef.extensions[NAME] as VariantPrimDef;\n\t\t\t\tfor (const mappingDef of variantPrimDef.mappings) {\n\t\t\t\t\tconst mapping = this.createMapping();\n\n\t\t\t\t\tif (mappingDef.material !== undefined) {\n\t\t\t\t\t\tmapping.setMaterial(context.materials[mappingDef.material]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const variantIndex of mappingDef.variants || []) {\n\t\t\t\t\t\tmapping.addVariant(variants[variantIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tmappingList.addMapping(mapping);\n\t\t\t\t}\n\n\t\t\t\tmesh.listPrimitives()[primIndex].setExtension(NAME, mappingList);\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst variants = this.listVariants();\n\t\tif (!variants.length) return this;\n\n\t\t// Write all top-level variant names.\n\t\tconst variantDefs = [];\n\t\tconst variantIndexMap = new Map<Variant, number>();\n\t\tfor (const variant of variants) {\n\t\t\tvariantIndexMap.set(variant, variantDefs.length);\n\t\t\tvariantDefs.push(context.createPropertyDef(variant));\n\t\t}\n\n\t\t// For each mesh primitive, write its material/variant mappings.\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\n\t\t\tconst meshIndex = context.meshIndexMap.get(mesh)!;\n\n\t\t\tmesh.listPrimitives().forEach((prim, primIndex) => {\n\t\t\t\tconst mappingList = prim.getExtension<MappingList>(NAME);\n\t\t\t\tif (!mappingList) return;\n\n\t\t\t\tconst primDef = context.jsonDoc.json.meshes![meshIndex].primitives[primIndex];\n\n\t\t\t\tconst mappingDefs = mappingList.listMappings().map((mapping) => {\n\t\t\t\t\tconst mappingDef = context.createPropertyDef(mapping) as VariantMappingDef;\n\n\t\t\t\t\tconst material = mapping.getMaterial();\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\tmappingDef.material = context.materialIndexMap.get(material)!;\n\t\t\t\t\t}\n\n\t\t\t\t\tmappingDef.variants = mapping.listVariants().map((variant) => variantIndexMap.get(variant)!);\n\n\t\t\t\t\treturn mappingDef;\n\t\t\t\t});\n\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\n\t\t\t\tprimDef.extensions[NAME] = { mappings: mappingDefs };\n\t\t\t});\n\t\t}\n\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\n\t\tjsonDoc.json.extensions[NAME] = { variants: variantDefs };\n\n\t\treturn this;\n\t}\n}\n","import {\n\tColorUtils,\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_VOLUME } from '../constants';\n\ninterface IVolume extends IProperty {\n\tthicknessFactor: number;\n\tthicknessTexture: Texture;\n\tthicknessTextureInfo: TextureInfo;\n\tattenuationDistance: number;\n\tattenuationColor: vec3;\n}\n\nconst { G } = TextureChannel;\n\n/**\n * # Volume\n *\n * Defines volume on a PBR {@link Material}. See {@link MaterialsVolume}.\n */\nexport class Volume extends ExtensionProperty<IVolume> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VOLUME;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VOLUME;\n\tpublic declare propertyType: 'Volume';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VOLUME;\n\t\tthis.propertyType = 'Volume';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IVolume> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tthicknessFactor: 0.0,\n\t\t\tthicknessTexture: null,\n\t\t\tthicknessTextureInfo: new TextureInfo(this.graph, 'thicknessTexture'),\n\t\t\tattenuationDistance: Infinity,\n\t\t\tattenuationColor: [1.0, 1.0, 1.0] as vec3,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Thickness.\n\t */\n\n\t/**\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n\t * boundary. The doubleSided property has no effect on volume boundaries.\n\t */\n\tpublic getThicknessFactor(): number {\n\t\treturn this.get('thicknessFactor');\n\t}\n\n\t/**\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n\t * boundary. The doubleSided property has no effect on volume boundaries.\n\t */\n\tpublic setThicknessFactor(factor: number): this {\n\t\treturn this.set('thicknessFactor', factor);\n\t}\n\n\t/**\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n\t * thicknessFactor.\n\t */\n\tpublic getThicknessTexture(): Texture | null {\n\t\treturn this.getRef('thicknessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its thickness texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getThicknessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('thicknessTexture') ? this.getRef('thicknessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n\t * thicknessFactor.\n\t */\n\tpublic setThicknessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('thicknessTexture', texture, { channels: G });\n\t}\n\n\t/**********************************************************************************************\n\t * Attenuation.\n\t */\n\n\t/**\n\t * Density of the medium given as the average distance in meters that light travels in the\n\t * medium before interacting with a particle.\n\t */\n\tpublic getAttenuationDistance(): number {\n\t\treturn this.get('attenuationDistance');\n\t}\n\n\t/**\n\t * Density of the medium given as the average distance in meters that light travels in the\n\t * medium before interacting with a particle.\n\t */\n\tpublic setAttenuationDistance(distance: number): this {\n\t\treturn this.set('attenuationDistance', distance);\n\t}\n\n\t/**\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic getAttenuationColor(): vec3 {\n\t\treturn this.get('attenuationColor');\n\t}\n\n\t/**\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic setAttenuationColor(color: vec3): this {\n\t\treturn this.set('attenuationColor', color);\n\t}\n\n\t/**\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic getAttenuationColorHex(): number {\n\t\treturn ColorUtils.factorToHex(this.getAttenuationColor());\n\t}\n\n\t/**\n\t * Color (sRGB) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic setAttenuationColorHex(hex: number): this {\n\t\tconst factor = this.getAttenuationColor().slice() as vec3;\n\t\treturn this.set('attenuationColor', ColorUtils.hexToFactor(hex, factor));\n\t}\n}\n","import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VOLUME } from '../constants';\nimport { Volume } from './volume';\n\nconst NAME = KHR_MATERIALS_VOLUME;\n\ninterface VolumeDef {\n\tthicknessFactor?: number;\n\tthicknessTexture?: GLTF.ITextureInfo;\n\tattenuationDistance?: number;\n\tattenuationColor?: vec3;\n}\n\n/**\n * # MaterialsVolume\n *\n * [KHR_materials_volume](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_volume/)\n * adds refraction, absorption, or scattering to a glTF PBR material already using transmission or\n * translucency.\n *\n * ![Illustration](/media/extensions/khr-materials-volume.png)\n *\n * > _**Figure:** Base color changes the amount of light passing through the volume boundary\n * > (left). The overall color of the object is the same everywhere, as if the object is covered\n * > with a colored, transparent foil. Absorption changes the amount of light traveling through the\n * > volume (right). The overall color depends on the distance the light traveled through it; at\n * > small distances (tail of the dragon) less light is absorbed and the color is brighter than at\n * > large distances. Source: Khronos Group._\n *\n * By default, a glTF 2.0 material describes the scattering properties of a surface enclosing an\n * infinitely thin volume. The surface defined by the mesh represents a thin wall. The volume\n * extension makes it possible to turn the surface into an interface between volumes. The mesh to\n * which the material is attached defines the boundaries of an homogeneous medium and therefore must\n * be manifold. Volumes provide effects like refraction, absorption and scattering. Scattering\n * effects will require future (TBD) extensions.\n *\n * The volume extension must be combined with {@link MaterialsTransmission} or\n * `KHR_materials_translucency` in order to define entry of light into the volume.\n *\n * Properties:\n * - {@link Volume}\n *\n * ### Example\n *\n * The `MaterialsVolume` class provides a single {@link ExtensionProperty} type, `Volume`, which\n * may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { MaterialsVolume, Volume } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const volumeExtension = document.createExtension(MaterialsVolume);\n *\n * // Create a Volume property.\n * const volume = volumeExtension.createVolume()\n * \t.setThicknessFactor(1.0)\n * \t.setThicknessTexture(texture)\n * \t.setAttenuationDistance(1.0)\n * \t.setAttenuationColorHex(0xFFEEEE);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_volume', volume);\n * ```\n *\n * A thickness texture is required in most realtime renderers, and can be baked in software such as\n * Blender or Substance Painter. When `thicknessFactor = 0`, all volumetric effects are disabled.\n */\nexport class MaterialsVolume extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Volume property for use on a {@link Material}. */\n\tpublic createVolume(): Volume {\n\t\treturn new Volume(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst volume = this.createVolume();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, volume);\n\n\t\t\t\tconst volumeDef = materialDef.extensions[NAME] as VolumeDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (volumeDef.thicknessFactor !== undefined) {\n\t\t\t\t\tvolume.setThicknessFactor(volumeDef.thicknessFactor);\n\t\t\t\t}\n\t\t\t\tif (volumeDef.attenuationDistance !== undefined) {\n\t\t\t\t\tvolume.setAttenuationDistance(volumeDef.attenuationDistance);\n\t\t\t\t}\n\t\t\t\tif (volumeDef.attenuationColor !== undefined) {\n\t\t\t\t\tvolume.setAttenuationColor(volumeDef.attenuationColor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (volumeDef.thicknessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = volumeDef.thicknessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tvolume.setThicknessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(volume.getThicknessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst volume = material.getExtension<Volume>(NAME);\n\t\t\t\tif (volume) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst volumeDef = (materialDef.extensions[NAME] = {} as VolumeDef);\n\n\t\t\t\t\tif (volume.getThicknessFactor() > 0) {\n\t\t\t\t\t\tvolumeDef.thicknessFactor = volume.getThicknessFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (Number.isFinite(volume.getAttenuationDistance())) {\n\t\t\t\t\t\tvolumeDef.attenuationDistance = volume.getAttenuationDistance();\n\t\t\t\t\t}\n\t\t\t\t\tif (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {\n\t\t\t\t\t\tvolumeDef.attenuationColor = volume.getAttenuationColor();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (volume.getThicknessTexture()) {\n\t\t\t\t\t\tconst texture = volume.getThicknessTexture()!;\n\t\t\t\t\t\tconst textureInfo = volume.getThicknessTextureInfo()!;\n\t\t\t\t\t\tvolumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MESH_QUANTIZATION } from '../constants';\n\nconst NAME = KHR_MESH_QUANTIZATION;\n\n/**\n * # MeshQuantization\n *\n * [`KHR_mesh_quantization`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_mesh_quantization/)\n * expands allowed component types for vertex attributes to include 16- and 8-bit storage.\n *\n * Quantization provides a memory/precision tradeoff — depending on the application needs, 16-bit or\n * 8-bit storage can be sufficient for mesh geometry, at 1/2 or 1/4 the size. For example, a 10x10\n * mesh might be written to a uint16 {@link Accessor}, with values `0–65536`, normalized to be\n * interpreted as `0–1`. With an additional 10x scale on any node {@link Node} instantiating the\n * quantized {@link Mesh}, the model retains its original scale with a minimal quality loss and\n * up to 50% file size reduction.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing more flexible use of\n * {@link Accessor} types for vertex attributes. Without the Extension, the same use of these data\n * types would yield an invalid glTF document, under the stricter core glTF specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { MeshQuantization } from '@gltf-transform/extensions';\n * import { quantize } from '@gltf-transform/functions';\n *\n * // Create an Extension attached to the Document.\n * const quantizationExtension = document.createExtension(MeshQuantization).setRequired(true);\n *\n * // Use Uint16Array, Uint8Array, Int16Array, and Int8Array in vertex accessors manually,\n * // or apply the provided quantize() function to compute quantized accessors automatically:\n * await document.transform(quantize({\n * \tquantizePosition: 16,\n * \tquantizeNormal: 12,\n * \tquantizeTexcoord: 14\n * }));\n * ```\n *\n * For more documentation about automatic quantization, see the {@link quantize} function.\n */\nexport class MeshQuantization extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tread(_: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\twrite(_: WriterContext): this {\n\t\treturn this;\n\t}\n}\n","import { KTX2Model, read as readKTX } from 'ktx-parse';\nimport {\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n} from '@gltf-transform/core';\nimport { KHR_TEXTURE_BASISU } from '../constants';\n\nconst NAME = KHR_TEXTURE_BASISU;\n\ninterface BasisuDef {\n\tsource: number;\n}\n\nclass KTX2ImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn (\n\t\t\tarray[0] === 0xab &&\n\t\t\tarray[1] === 0x4b &&\n\t\t\tarray[2] === 0x54 &&\n\t\t\tarray[3] === 0x58 &&\n\t\t\tarray[4] === 0x20 &&\n\t\t\tarray[5] === 0x32 &&\n\t\t\tarray[6] === 0x30 &&\n\t\t\tarray[7] === 0xbb &&\n\t\t\tarray[8] === 0x0d &&\n\t\t\tarray[9] === 0x0a &&\n\t\t\tarray[10] === 0x1a &&\n\t\t\tarray[11] === 0x0a\n\t\t);\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\tconst container = readKTX(array);\n\t\treturn [container.pixelWidth, container.pixelHeight];\n\t}\n\tgetChannels(array: Uint8Array): number {\n\t\tconst container = readKTX(array);\n\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\tif (dfd.colorModel === KTX2Model.ETC1S) {\n\t\t\treturn dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xf) === 15 ? 4 : 3;\n\t\t} else if (dfd.colorModel === KTX2Model.UASTC) {\n\t\t\treturn (dfd.samples[0].channelID & 0xf) === 3 ? 4 : 3;\n\t\t}\n\t\tthrow new Error(`Unexpected KTX2 colorModel, \"${dfd.colorModel}\".`);\n\t}\n\tgetGPUByteLength(array: Uint8Array): number {\n\t\tconst container = readKTX(array);\n\t\tconst hasAlpha = this.getChannels(array) > 3;\n\n\t\tlet uncompressedBytes = 0;\n\t\tfor (let i = 0; i < container.levels.length; i++) {\n\t\t\tconst level = container.levels[i];\n\n\t\t\t// Use level.uncompressedByteLength for UASTC; for ETC1S it's 0.\n\t\t\tif (level.uncompressedByteLength) {\n\t\t\t\tuncompressedBytes += level.uncompressedByteLength;\n\t\t\t} else {\n\t\t\t\tconst levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));\n\t\t\t\tconst levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));\n\t\t\t\tconst blockSize = hasAlpha ? 16 : 8;\n\t\t\t\tuncompressedBytes += (levelWidth / 4) * (levelHeight / 4) * blockSize;\n\t\t\t}\n\t\t}\n\n\t\treturn uncompressedBytes;\n\t}\n}\n\n/**\n * # TextureBasisu\n *\n * [`KHR_texture_basisu`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu)\n * enables KTX2 GPU textures with Basis Universal supercompression for any material texture.\n *\n * GPU texture formats, unlike traditional image formats, remain compressed in GPU memory. As a\n * result, they (1) upload to the GPU much more quickly, and (2) require much less GPU memory. In\n * certain cases they may also have smaller filesizes than PNG or JPEG textures, but this is not\n * guaranteed. GPU textures often require more careful tuning during compression to maintain image\n * quality, but this extra effort is worthwhile for applications that need to maintain a smooth\n * framerate while uploading images, or where GPU memory is limited.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/ktx2` MIME type\n * and passing KTX2 image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { TextureBasisu } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const basisuExtension = document.createExtension(TextureBasisu)\n * \t.setRequired(true);\n * document.createTexture('MyCompressedTexture')\n * \t.setMimeType('image/ktx2')\n * \t.setImage(fs.readFileSync('my-texture.ktx2'));\n * ```\n *\n * Compression is not done automatically when adding the extension as shown above — you must\n * compress the image data first, then pass the `.ktx2` payload to {@link Texture.setImage}. The\n * [glTF-Transform CLI](/cli.html) has functions to help with this, or any similar KTX2-capable\n * utility will work.\n *\n * When the `KHR_texture_basisu` extension is added to a file by glTF-Transform, the extension\n * should always be required. This tool does not support writing assets that \"fall back\" to optional\n * PNG or JPEG image data.\n *\n * > _**NOTICE:** Compressing some textures — particularly 3-component (RGB) normal maps, and\n * > occlusion/roughness/metalness maps, may give poor results with the ETC1S compression option.\n * > These issues can often be avoided with the larger UASTC compression option, or by upscaling the\n * > texture before compressing it.\n * >\n * > For best results when authoring new textures, use\n * > [texture dilation](https://docs.substance3d.com/spdoc/padding-134643719.html) and minimize\n * > prominent UV seams._\n */\nexport class TextureBasisu extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/ktx2', new KTX2ImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tcontext.jsonDoc.json.textures!.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\tconst basisuDef = textureDef.extensions[NAME] as BasisuDef;\n\t\t\t\ttextureDef.source = basisuDef.source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tjsonDoc.json.textures!.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n","import { ExtensionProperty, IProperty, Nullable, vec2 } from '@gltf-transform/core';\nimport { PropertyType } from '@gltf-transform/core';\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\n\ninterface ITransform extends IProperty {\n\toffset: vec2;\n\trotation: number;\n\tscale: vec2;\n\ttexCoord: number | null; // null → do not override TextureInfo.\n}\n\n/**\n * # Transform\n *\n * Defines UV transform for a {@link TextureInfo}. See {@link TextureTransform}.\n */\nexport class Transform extends ExtensionProperty<ITransform> {\n\tpublic static EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;\n\tpublic declare extensionName: typeof KHR_TEXTURE_TRANSFORM;\n\tpublic declare propertyType: 'Transform';\n\tpublic declare parentTypes: [PropertyType.TEXTURE_INFO];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_TEXTURE_TRANSFORM;\n\t\tthis.propertyType = 'Transform';\n\t\tthis.parentTypes = [PropertyType.TEXTURE_INFO];\n\t}\n\n\tprotected getDefaults(): Nullable<ITransform> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\toffset: [0.0, 0.0] as vec2,\n\t\t\trotation: 0,\n\t\t\tscale: [1.0, 1.0] as vec2,\n\t\t\ttexCoord: null,\n\t\t});\n\t}\n\n\tpublic getOffset(): vec2 {\n\t\treturn this.get('offset');\n\t}\n\tpublic setOffset(offset: vec2): this {\n\t\treturn this.set('offset', offset);\n\t}\n\n\tpublic getRotation(): number {\n\t\treturn this.get('rotation');\n\t}\n\tpublic setRotation(rotation: number): this {\n\t\treturn this.set('rotation', rotation);\n\t}\n\n\tpublic getScale(): vec2 {\n\t\treturn this.get('scale');\n\t}\n\tpublic setScale(scale: vec2): this {\n\t\treturn this.set('scale', scale);\n\t}\n\n\tpublic getTexCoord(): number | null {\n\t\treturn this.get('texCoord');\n\t}\n\tpublic setTexCoord(texCoord: number | null): this {\n\t\treturn this.set('texCoord', texCoord);\n\t}\n}\n","import { Extension, MathUtils, ReaderContext, WriterContext, vec2 } from '@gltf-transform/core';\nimport { KHR_TEXTURE_TRANSFORM } from '../constants';\nimport { Transform } from './transform';\n\nconst NAME = KHR_TEXTURE_TRANSFORM;\n\ninterface TransformDef {\n\toffset?: vec2;\n\trotation?: number;\n\tscale?: vec2;\n\ttexCoord?: number;\n}\n\n/**\n * # TextureTransform\n *\n * [`KHR_texture_transform`](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/)\n * adds offset, rotation, and scale to {@link TextureInfo} properties.\n *\n * Affine UV transforms are useful for reducing the number of textures the GPU must load, improving\n * performance when used in techniques like texture atlases. UV transforms cannot be animated at\n * this time.\n *\n * Properties:\n * - {@link Transform}\n *\n * ### Example\n *\n * The `TextureTransform` class provides a single {@link ExtensionProperty} type, `Transform`, which\n * may be attached to any {@link TextureInfo} instance. For example:\n *\n * ```typescript\n * import { TextureTransform } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const transformExtension = document.createExtension(TextureTransform)\n * \t.setRequired(true);\n *\n * // Create a reusable Transform.\n * const transform = transformExtension.createTransform()\n * \t.setScale([100, 100]);\n *\n * // Apply the Transform to a Material's baseColorTexture.\n * document.createMaterial()\n * \t.setBaseColorTexture(myTexture)\n * \t.getBaseColorTextureInfo()\n * \t.setExtension('KHR_texture_transform', transform);\n * ```\n */\nexport class TextureTransform extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Transform property for use on a {@link TextureInfo}. */\n\tpublic createTransform(): Transform {\n\t\treturn new Transform(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tfor (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {\n\t\t\tif (!textureInfoDef.extensions || !textureInfoDef.extensions[NAME]) continue;\n\n\t\t\tconst transform = this.createTransform();\n\t\t\tconst transformDef = textureInfoDef.extensions[NAME] as TransformDef;\n\n\t\t\tif (transformDef.offset !== undefined) transform.setOffset(transformDef.offset);\n\t\t\tif (transformDef.rotation !== undefined) transform.setRotation(transformDef.rotation);\n\t\t\tif (transformDef.scale !== undefined) transform.setScale(transformDef.scale);\n\t\t\tif (transformDef.texCoord !== undefined) transform.setTexCoord(transformDef.texCoord);\n\n\t\t\ttextureInfo.setExtension(NAME, transform);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst textureInfoEntries = Array.from(context.textureInfoDefMap.entries());\n\t\tfor (const [textureInfo, textureInfoDef] of textureInfoEntries) {\n\t\t\tconst transform = textureInfo.getExtension<Transform>(NAME);\n\t\t\tif (!transform) continue;\n\n\t\t\ttextureInfoDef.extensions = textureInfoDef.extensions || {};\n\t\t\tconst transformDef = {} as TransformDef;\n\n\t\t\tconst eq = MathUtils.eq;\n\t\t\tif (!eq(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();\n\t\t\tif (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();\n\t\t\tif (!eq(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();\n\t\t\tif (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord()!;\n\n\t\t\ttextureInfoDef.extensions[NAME] = transformDef;\n\t\t}\n\t\treturn this;\n\t}\n}\n","/** @module extensions */\n\nimport { MeshGPUInstancing } from './ext-mesh-gpu-instancing';\nimport { MeshoptCompression } from './ext-meshopt-compression';\nimport { TextureWebP } from './ext-texture-webp';\nimport { DracoMeshCompression } from './khr-draco-mesh-compression';\nimport { LightsPunctual } from './khr-lights-punctual';\nimport { MaterialsClearcoat } from './khr-materials-clearcoat';\nimport { MaterialsEmissiveStrength } from './khr-materials-emissive-strength';\nimport { MaterialsIOR } from './khr-materials-ior';\nimport { MaterialsPBRSpecularGlossiness } from './khr-materials-pbr-specular-glossiness';\nimport { MaterialsSheen } from './khr-materials-sheen';\nimport { MaterialsSpecular } from './khr-materials-specular';\nimport { MaterialsTransmission } from './khr-materials-transmission';\nimport { MaterialsUnlit } from './khr-materials-unlit';\nimport { MaterialsVariants } from './khr-materials-variants';\nimport { MaterialsVolume } from './khr-materials-volume';\nimport { MeshQuantization } from './khr-mesh-quantization';\nimport { TextureBasisu } from './khr-texture-basisu';\nimport { TextureTransform } from './khr-texture-transform';\n\nexport const KHRONOS_EXTENSIONS = [\n\tDracoMeshCompression,\n\tLightsPunctual,\n\tMaterialsClearcoat,\n\tMaterialsEmissiveStrength,\n\tMaterialsIOR,\n\tMaterialsPBRSpecularGlossiness,\n\tMaterialsSpecular,\n\tMaterialsSheen,\n\tMaterialsTransmission,\n\tMaterialsUnlit,\n\tMaterialsVariants,\n\tMaterialsVolume,\n\tMeshQuantization,\n\tTextureBasisu,\n\tTextureTransform,\n];\n\nexport const ALL_EXTENSIONS = [\n\tMeshGPUInstancing,\n\tMeshoptCompression,\n\tTextureWebP,\n\t...KHRONOS_EXTENSIONS,\n];\n\nexport * from './ext-mesh-gpu-instancing';\nexport * from './ext-meshopt-compression';\nexport * from './ext-texture-webp';\nexport * from './khr-draco-mesh-compression';\nexport * from './khr-lights-punctual';\nexport * from './khr-materials-clearcoat';\nexport * from './khr-materials-emissive-strength';\nexport * from './khr-materials-ior';\nexport * from './khr-materials-sheen';\nexport * from './khr-materials-specular';\nexport * from './khr-materials-pbr-specular-glossiness';\nexport * from './khr-materials-transmission';\nexport * from './khr-materials-unlit';\nexport * from './khr-materials-variants';\nexport * from './khr-materials-volume';\nexport * from './khr-mesh-quantization';\nexport * from './khr-texture-basisu';\nexport * from './khr-texture-transform';\n"],"names":["INSTANCE_ATTRIBUTE","InstancedMesh","ExtensionProperty","init","this","extensionName","propertyType","parentTypes","PropertyType","NODE","getDefaults","Object","assign","super","attributes","getAttribute","semantic","getRefMap","setAttribute","accessor","setRefMap","usage","listAttributes","listRefMapValues","listSemantics","listRefMapKeys","EXTENSION_NAME","NAME","MeshGPUInstancing","Extension","provideTypes","prewriteTypes","ACCESSOR","createInstancedMesh","document","getGraph","read","context","jsonDoc","json","nodes","forEach","nodeDef","nodeIndex","extensions","instancedMeshDef","instancedMesh","accessors","setExtension","prewrite","accessorUsageGroupedByParent","add","prop","properties","attribute","addAccessorToUsageGroup","write","getRoot","listNodes","node","getExtension","nodeIndexMap","get","accessorIndexMap","EncoderMethod","MeshoptMode","MeshoptFilter","BYTE","SHORT","FLOAT","Accessor","ComponentType","normalize","denormalize","MathUtils","prepareAccessor","encoder","mode","filterOptions","filter","bits","result","array","getArray","byteStride","getElementSize","getComponentSize","componentType","getComponentType","normalized","getNormalized","ATTRIBUTES","NONE","srcArray","dstArray","Float32Array","length","i","denormalizeArray","EXPONENTIAL","encodeFilterExp","getCount","OCTAHEDRAL","il","padNormals","encodeFilterOct","QUATERNION","encodeFilterQuat","Error","min","getMin","max","getMax","map","v","elementSize","elementStride","BufferUtils","padNumber","BYTES_PER_ELEMENT","constructor","j","padArrayElements","byteLength","getMeshoptMode","WriterContext","BufferViewUsage","ELEMENT_ARRAY_BUFFER","listParents","some","parent","Primitive","getMode","Mode","TRIANGLES","INDICES","getMeshoptFilter","doc","refs","listParentEdges","edge","getParent","Root","ref","refName","getName","refKey","getAttributes","key","startsWith","targetPath","getTargetPath","sampler","AnimationSampler","channel","AnimationChannel","DEFAULT_ENCODER_OPTIONS","method","QUANTIZE","MeshoptCompression","prereadTypes","BUFFER","PRIMITIVE","readDependencies","writeDependencies","_decoder","_decoderFallbackBufferMap","Map","_encoder","_encoderOptions","_encoderFallbackBuffer","_encoderBufferViews","_encoderBufferViewData","_encoderBufferViewAccessors","install","dependency","setEncoderOptions","options","preread","isRequired","supported","_prereadBuffers","_prereadPrimitives","bufferViews","viewDef","index","meshoptDef","byteOffset","count","stride","Uint8Array","bufferDef","buffers","buffer","source","toView","uri","resources","GLB_BUFFER","decodeGltfBuffer","fallback","set","_context","fallbackBuffer","swap","dispose","_prewriteAccessors","_prewriteBuffers","createBuffer","fallbackBufferIndex","listBuffers","indexOf","listAccessors","getAccessorUsage","FILTER","preparedAccessor","getBuffer","bufferIndex","join","bufferView","bufferViewData","bufferViewAccessors","target","USAGE_TO_TARGET","ARRAY_BUFFER","undefined","[object Object]","accessorDef","createAccessorDef","push","EXT_meshopt_compression","otherBufferViews","concat","encodeGltfBuffer","compressedData","pad","fallbackBufferByteOffset","bufferViewIndex","otherBufferViewsIndexMap","finalBufferViewDef","compressedByteOffset","bufferIndexMap","fallbackBufferDef","WEBPImageUtils","match","getSize","RIFF","decodeText","slice","WEBP","view","DataView","offset","chunkId","getUint8","chunkByteLength","getUint32","getInt16","b0","b1","b2","getChannels","_buffer","TextureWebP","TEXTURE","ImageUtils","registerFormat","textures","textureDef","listTextures","texture","getMimeType","imageIndex","imageIndexMap","decoderModule","COMPONENT_ARRAY","DATA_TYPE","encoderModule","decodeGeometry","decoder","data","DecoderBuffer","Init","GetEncodedGeometryType","TRIANGULAR_MESH","dracoMesh","Mesh","DecodeBufferToMesh","ok","ptr","destroy","decodeIndex","mesh","numIndices","num_faces","indices","num_points","Uint16Array","_malloc","GetTrianglesUInt16Array","HEAPU16","Uint32Array","GetTrianglesUInt32Array","HEAPU32","_free","decodeAttribute","dataType","ArrayCtor","numComponents","num_components","numValues","GetAttributeDataArrayForAllPoints","HEAPF32","AttributeEnum","DEFAULT_QUANTIZATION_BITS","POSITION","NORMAL","COLOR","TEX_COORD","GENERIC","decodeSpeed","encodeSpeed","EDGEBREAKER","quantizationBits","quantizationVolume","encodeGeometry","prim","_options","Encoder","builder","MeshBuilder","attributeIDs","dracoBuffer","DracoInt8Array","attributeEnum","getAttributeEnum","attributeID","addAttribute","SetAttributeQuantization","range","Math","SetAttributeExplicitQuantization","getIndices","AddFacesToMesh","SetSpeedOptions","SetTrackEncodedProperties","SEQUENTIAL","listTargets","SetEncodingMethod","MESH_SEQUENTIAL_ENCODING","MESH_EDGEBREAKER_ENCODING","EncodeMeshToDracoBuffer","GetValue","prevNumVertices","numVertices","GetNumberOfEncodedPoints","GetNumberOfEncodedFaces","itemSize","UNSIGNED_BYTE","AddUInt8Attribute","AddInt8Attribute","UNSIGNED_SHORT","AddUInt16Attribute","AddInt16Attribute","UNSIGNED_INT","AddUInt32Attribute","AddFloatAttribute","DracoMeshCompression","_decoderModule","_encoderModule","Int16Array","Int8Array","DT_FLOAT32","DT_UINT32","DT_UINT16","DT_UINT8","DT_INT16","DT_INT8","logger","getLogger","dracoMeshes","meshDefs","meshes","meshDef","primDef","primitives","dracoDef","bufferViewDef","Decoder","debug","dracoAttribute","GetAttributeByUniqueId","attributeArray","setArray","Array","from","values","_propertyType","JSON","stringify","primitiveHashMap","included","Set","excluded","listMeshes","listPrimitives","warn","accessorIndices","includedAccessors","includedHashKeys","primToHashKey","hashKey","createHashKey","has","dstIndices","clone","dstAttribute","keys","size","ROOT","attr","listDracoPrimitives","primitiveEncodingMap","listScenes","bounds","pop","primHash","accessorDefs","encodedPrim","indicesDef","attributeDef","extensionData","dracoContext","meshIndexMap","extensionsUsed","name","extensionsRequired","indexMap","hashElements","sort","Light","color","intensity","type","Type","POINT","innerConeAngle","outerConeAngle","PI","getColor","setColor","getColorHex","ColorUtils","factorToHex","setColorHex","hex","hexToFactor","getIntensity","setIntensity","getType","setType","getRange","setRange","getInnerConeAngle","setInnerConeAngle","angle","getOuterConeAngle","setOuterConeAngle","SPOT","DIRECTIONAL","LightsPunctual","createLight","lights","lightDef","light","setName","lightDefs","lightIndexMap","property","eq","R","G","B","TextureChannel","Clearcoat","MATERIAL","clearcoatFactor","clearcoatTexture","clearcoatTextureInfo","TextureInfo","graph","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatRoughnessTextureInfo","clearcoatNormalScale","clearcoatNormalTexture","clearcoatNormalTextureInfo","getClearcoatFactor","setClearcoatFactor","factor","getClearcoatTexture","getRef","getClearcoatTextureInfo","setClearcoatTexture","setRef","channels","getClearcoatRoughnessFactor","setClearcoatRoughnessFactor","getClearcoatRoughnessTexture","getClearcoatRoughnessTextureInfo","setClearcoatRoughnessTexture","getClearcoatNormalScale","setClearcoatNormalScale","scale","getClearcoatNormalTexture","getClearcoatNormalTextureInfo","setClearcoatNormalTexture","MaterialsClearcoat","createClearcoat","textureDefs","materials","materialDef","materialIndex","clearcoat","clearcoatDef","textureInfoDef","setTextureInfo","listMaterials","material","materialIndexMap","textureInfo","createTextureInfoDef","EmissiveStrength","emissiveStrength","getEmissiveStrength","setEmissiveStrength","strength","MaterialsEmissiveStrength","createEmissiveStrength","emissiveStrengthDef","IOR","ior","getIOR","setIOR","MaterialsIOR","createIOR","iorDef","A","PBRSpecularGlossiness","diffuseFactor","diffuseTexture","diffuseTextureInfo","specularFactor","glossinessFactor","specularGlossinessTexture","specularGlossinessTextureInfo","getDiffuseFactor","setDiffuseFactor","getDiffuseHex","setDiffuseHex","getDiffuseTexture","getDiffuseTextureInfo","setDiffuseTexture","getSpecularFactor","setSpecularFactor","getGlossinessFactor","setGlossinessFactor","getSpecularGlossinessTexture","getSpecularGlossinessTextureInfo","setSpecularGlossinessTexture","MaterialsPBRSpecularGlossiness","createPBRSpecularGlossiness","specGloss","specGlossDef","Sheen","sheenColorFactor","sheenColorTexture","sheenColorTextureInfo","sheenRoughnessFactor","sheenRoughnessTexture","sheenRoughnessTextureInfo","getSheenColorFactor","getSheenColorHex","setSheenColorFactor","setSheenColorHex","getSheenColorTexture","getSheenColorTextureInfo","setSheenColorTexture","getSheenRoughnessFactor","setSheenRoughnessFactor","getSheenRoughnessTexture","getSheenRoughnessTextureInfo","setSheenRoughnessTexture","MaterialsSheen","createSheen","sheen","sheenDef","Specular","specularTexture","specularTextureInfo","specularColorFactor","specularColorTexture","specularColorTextureInfo","getSpecularColorFactor","setSpecularColorFactor","getSpecularColorHex","setSpecularColorHex","getSpecularTexture","getSpecularTextureInfo","setSpecularTexture","getSpecularColorTexture","getSpecularColorTextureInfo","setSpecularColorTexture","MaterialsSpecular","createSpecular","specular","specularDef","Transmission","transmissionFactor","transmissionTexture","transmissionTextureInfo","getTransmissionFactor","setTransmissionFactor","getTransmissionTexture","getTransmissionTextureInfo","setTransmissionTexture","MaterialsTransmission","createTransmission","transmission","transmissionDef","Unlit","MaterialsUnlit","createUnlit","Mapping","variants","getMaterial","setMaterial","addVariant","variant","addRef","removeVariant","removeRef","listVariants","listRefs","MappingList","mappings","addMapping","mapping","removeMapping","listMappings","Variant","MaterialsVariants","createMappingList","createVariant","createMapping","variantDef","meshIndex","primIndex","mappingList","variantPrimDef","mappingDef","variantIndex","variantDefs","variantIndexMap","createPropertyDef","mappingDefs","Volume","thicknessFactor","thicknessTexture","thicknessTextureInfo","attenuationDistance","Infinity","attenuationColor","getThicknessFactor","setThicknessFactor","getThicknessTexture","getThicknessTextureInfo","setThicknessTexture","getAttenuationDistance","setAttenuationDistance","distance","getAttenuationColor","setAttenuationColor","getAttenuationColorHex","setAttenuationColorHex","MaterialsVolume","createVolume","volume","volumeDef","Number","isFinite","MeshQuantization","_","KTX2ImageUtils","container","readKTX","pixelWidth","pixelHeight","dfd","dataFormatDescriptor","colorModel","KTX2Model","ETC1S","samples","channelID","UASTC","getGPUByteLength","hasAlpha","uncompressedBytes","levels","level","uncompressedByteLength","floor","pow","TextureBasisu","Transform","TEXTURE_INFO","rotation","texCoord","getOffset","setOffset","getRotation","setRotation","getScale","setScale","getTexCoord","setTexCoord","TextureTransform","createTransform","textureInfos","entries","transform","transformDef","textureInfoEntries","textureInfoDefMap","KHRONOS_EXTENSIONS","ALL_EXTENSIONS"],"mappings":"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"}