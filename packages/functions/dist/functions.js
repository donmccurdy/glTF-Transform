var e=require("@gltf-transform/core"),t=require("ndarray-pixels"),n=require("@gltf-transform/extensions"),r=require("gl-matrix/mat4"),o=require("gl-matrix/vec3"),s=require("ndarray"),i=require("ndarray-lanczos");function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var c=/*#__PURE__*/a(s);const u=function(e,n,r){try{if(!e)return Promise.resolve(null);const o=e.getImage();return o?Promise.resolve(t.getPixels(o,e.getMimeType())).then(function(e){for(let t=0;t<e.shape[0];++t)for(let n=0;n<e.shape[1];++n)r(e,t,n);return Promise.resolve(t.savePixels(e,"image/png")).then(function(e){return n.setImage(e).setMimeType("image/png")})}):Promise.resolve(null)}catch(e){return Promise.reject(e)}};function l(e,t){return Object.defineProperty(t,"name",{value:e}),t}function f(t){const n=t.getIndices(),r=t.getAttribute("POSITION");switch(t.getMode()){case e.Primitive.Mode.POINTS:return r.getCount();case e.Primitive.Mode.LINES:return n?n.getCount()/2:r.getCount()/2;case e.Primitive.Mode.LINE_LOOP:return r.getCount();case e.Primitive.Mode.LINE_STRIP:return r.getCount()-1;case e.Primitive.Mode.TRIANGLES:return n?n.getCount()/3:r.getCount()/3;case e.Primitive.Mode.TRIANGLE_STRIP:case e.Primitive.Mode.TRIANGLE_FAN:return r.getCount()-2;default:throw new Error("Unexpected mode: "+t.getMode())}}class g{constructor(){this._map=new Map}get size(){return this._map.size}has(e){return this._map.has(e)}add(e,t){let n=this._map.get(e);return n||(n=new Set,this._map.set(e,n)),n.add(t),this}get(e){return this._map.get(e)||new Set}keys(){return this._map.keys()}}const p={pivot:"center"},m="colorspace",d={propertyTypes:[e.PropertyType.ACCESSOR,e.PropertyType.MESH,e.PropertyType.TEXTURE,e.PropertyType.MATERIAL]},h=function(t=d){const n={...d,...t},r=new Set(n.propertyTypes);for(const e of n.propertyTypes)if(!d.propertyTypes.includes(e))throw new Error(`dedup: Unsupported deduplication on type "${e}".`);return l("dedup",t=>{const n=t.getLogger();r.has(e.PropertyType.ACCESSOR)&&function(t,n){const r=new Set,o=new Set,s=new Set,i=new Set,a=n.getRoot().listMeshes();a.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(e=>o.add(e));const t=e.getIndices();t&&r.add(t)})});for(const e of n.getRoot().listAnimations())for(const t of e.listSamplers()){const e=t.getInput(),n=t.getOutput();e&&s.add(e),n&&i.add(n)}function c(t){const n=new Map;for(let r=0;r<t.length;r++){const o=t[r],s=e.BufferUtils.toView(o.getArray());if(!n.has(o))for(let r=0;r<t.length;r++){const i=t[r];o!==i&&(n.has(i)||o.getType()===i.getType()&&o.getComponentType()===i.getComponentType()&&o.getCount()===i.getCount()&&o.getNormalized()===i.getNormalized()&&e.BufferUtils.equals(s,e.BufferUtils.toView(i.getArray()))&&n.set(i,o))}}return n}const u=c(Array.from(r));t.debug(`dedup: Found ${u.size} duplicates among ${r.size} indices.`);const l=c(Array.from(o));t.debug(`dedup: Found ${l.size} duplicates among ${o.size} attributes.`);const f=c(Array.from(s)),g=c(Array.from(i));t.debug(`dedup: Found ${f.size+g.size} duplicates among ${s.size+i.size} animation accessors.`),a.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(t=>{l.has(t)&&e.swap(t,l.get(t))});const t=e.getIndices();t&&u.has(t)&&e.swap(t,u.get(t))})}),Array.from(u.keys()).forEach(e=>e.dispose()),Array.from(l.keys()).forEach(e=>e.dispose());for(const e of n.getRoot().listAnimations())for(const t of e.listSamplers()){const e=t.getInput(),n=t.getOutput();e&&f.has(e)&&t.swap(e,f.get(e)),n&&g.has(n)&&t.swap(n,g.get(n))}Array.from(f.keys()).forEach(e=>e.dispose()),Array.from(g.keys()).forEach(e=>e.dispose())}(n,t),r.has(e.PropertyType.MESH)&&function(t,n){const r=n.getRoot(),o=new Map;r.listAccessors().forEach((e,t)=>o.set(e,t)),r.listMaterials().forEach((e,t)=>o.set(e,t));const s=r.listMeshes().length,i=new Map;for(const t of r.listMeshes()){const n=[];for(const e of t.listPrimitives())n.push(y(e,o));const r=n.join(";");if(i.has(r)){const n=i.get(r);t.listParents().forEach(r=>{r.propertyType!==e.PropertyType.ROOT&&r.swap(t,n)}),t.dispose()}else i.set(r,t)}t.debug(`dedup: Found ${s-i.size} duplicates among ${s} meshes.`)}(n,t),r.has(e.PropertyType.TEXTURE)&&function(t,n){const r=n.getRoot(),o=r.listTextures(),s=new Map;for(let t=0;t<o.length;t++){const n=o[t],r=n.getImage();if(!s.has(n))for(let t=0;t<o.length;t++){const i=o[t],a=i.getImage();if(n===i)continue;if(s.has(i))continue;if(n.getMimeType()!==i.getMimeType())continue;const c=n.getSize(),u=i.getSize();c&&u&&c[0]===u[0]&&c[1]===u[1]&&r&&a&&e.BufferUtils.equals(r,a)&&s.set(i,n)}}t.debug(`dedup: Found ${s.size} duplicates among ${r.listTextures().length} textures.`),Array.from(s.entries()).forEach(([t,n])=>{t.listParents().forEach(r=>{r instanceof e.Root||r.swap(t,n)}),t.dispose()})}(n,t),r.has(e.PropertyType.MATERIAL)&&function(t,n){const r=n.getRoot(),o=r.listMaterials(),s=new Map;for(let e=0;e<o.length;e++){const t=o[e];if(!s.has(t))for(let e=0;e<o.length;e++){const n=o[e];t!==n&&(s.has(n)||t.equals(n)&&s.set(n,t))}}t.debug(`dedup: Found ${s.size} duplicates among ${r.listMaterials().length} materials.`),Array.from(s.entries()).forEach(([t,n])=>{t.listParents().forEach(r=>{r instanceof e.Root||r.swap(t,n)}),t.dispose()})}(n,t),n.debug("dedup: Complete.")})};function y(t,n){const r=[];for(const e of t.listSemantics()){const o=t.getAttribute(e);r.push(e+":"+n.get(o))}if(t instanceof e.Primitive){const e=t.getIndices();e&&r.push("indices:"+n.get(e));const o=t.getMaterial();o&&r.push("material:"+n.get(o)),r.push("mode:"+t.getMode());for(const e of t.listTargets())r.push("target:"+y(e,n))}return r.join(",")}const A={pattern:/^((?!JOINTS_).)*$/};function T(e,t){for(const n of e.listSemantics())E(n,e.getAttribute(n),t);for(const n of e.listTargets())for(const e of n.listSemantics())E(e,n.getAttribute(e),t)}function E(e,t,n){if(!t.getArray())return;if(!n.pattern.test(e))return;if(t.getComponentSize()>=4)return;const r=t.getArray(),o=new Float32Array(r.length);for(let e=0,n=t.getCount(),s=[];e<n;e++)s=t.getElement(e,s),t.setArray(o).setElement(e,s).setArray(r);t.setArray(o).setNormalized(!1)}function S(t){return{properties:t.getRoot().listScenes().map(t=>{const n=t.listChildren()[0],r=e.bounds(t);return{name:t.getName(),rootName:n?n.getName():"",bboxMin:M(r.min),bboxMax:M(r.max)}})}}function I(e){return{properties:e.getRoot().listMeshes().map(e=>{const t=e.listParents().filter(e=>"Root"!==e.propertyType).length;let n=0,r=0;const o=new Set,s=new Set,i=new Set;e.listPrimitives().forEach(e=>{for(const t of e.listSemantics()){const n=e.getAttribute(t);o.add(t+":"+N(n.getArray())),i.add(n)}for(const t of e.listTargets())t.listAttributes().forEach(e=>i.add(e));const t=e.getIndices();t&&(s.add(N(t.getArray())),i.add(t)),r+=e.listAttributes()[0].getCount(),n+=f(e)});let a=0;Array.from(i).forEach(e=>a+=e.getArray().byteLength);const c=e.listPrimitives().map(e=>w[e.getMode()]);return{name:e.getName(),mode:Array.from(new Set(c)),primitives:e.listPrimitives().length,glPrimitives:n,vertices:r,indices:Array.from(s).sort(),attributes:Array.from(o).sort(),instances:t,size:a}})}}function b(t){return{properties:t.getRoot().listMaterials().map(n=>{const r=n.listParents().filter(e=>"Root"!==e.propertyType).length,o=new Set(n.listExtensions()),s=t.getGraph().listEdges().filter(t=>{const r=t.getChild(),s=t.getParent();return r instanceof e.Texture&&s===n||!!(r instanceof e.Texture&&s instanceof e.ExtensionProperty&&o.has(s))}).map(e=>e.getName());return{name:n.getName(),instances:r,textures:s,alphaMode:n.getAlphaMode(),doubleSided:n.getDoubleSided()}})}}function P(t){return{properties:t.getRoot().listTextures().map(n=>{const r=n.listParents().filter(e=>"Root"!==e.propertyType).length,o=t.getGraph().listParentEdges(n).map(e=>e.getName()).filter(e=>"texture"!==e),s=e.ImageUtils.getSize(n.getImage(),n.getMimeType());return{name:n.getName(),uri:n.getURI(),slots:Array.from(new Set(o)),instances:r,mimeType:n.getMimeType(),resolution:s?s.join("x"):"",size:n.getImage().byteLength,gpuSize:e.ImageUtils.getMemSize(n.getImage(),n.getMimeType())}})}}function R(e){return{properties:e.getRoot().listAnimations().map(e=>{let t=Infinity,n=-Infinity;e.listSamplers().forEach(e=>{const r=e.getInput();r&&(t=Math.min(t,r.getMin([])[0]),n=Math.max(n,r.getMax([])[0]))});let r=0,o=0;const s=new Set;return e.listSamplers().forEach(e=>{const t=e.getInput(),n=e.getOutput();t&&(o+=t.getCount(),s.add(t),n&&s.add(n))}),Array.from(s).forEach(e=>{r+=e.getArray().byteLength}),{name:e.getName(),channels:e.listChannels().length,samplers:e.listSamplers().length,duration:Math.round(1e3*(n-t))/1e3,keyframes:o,size:r}})}}const w=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"];function M(e){for(let t=0;t<e.length;t++)e[t].toFixed&&(e[t]=Number(e[t].toFixed(5)));return e}function N(e){return e.constructor.name.replace("Array","").toLowerCase()}const C={};function x(t,n){let r,o=0;for(;r=t.pop();){if(r.listChildren().length||r.getCamera()||r.getMesh()||r.getSkin()||r.listExtensions().length)continue;const n=r.getParent();n instanceof e.Node&&t.push(n),r.dispose(),o++}n.debug(`instance: Removed ${o} unused nodes.`)}function v(e,t,n,r){const o=n.listPrimitives()[0].getAttribute("POSITION").getBuffer(),s=e.createAccessor().setType("VEC3").setArray(new Float32Array(3*r)).setBuffer(o),i=e.createAccessor().setType("VEC4").setArray(new Float32Array(4*r)).setBuffer(o),a=e.createAccessor().setType("VEC3").setArray(new Float32Array(3*r)).setBuffer(o);return t.createInstancedMesh().setAttribute("TRANSLATION",s).setAttribute("ROTATION",i).setAttribute("SCALE",a)}const O=/*#__PURE__*/"undefined"!=typeof Symbol?Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator")):"@@iterator";function z(e,t,n){if(!e.s){if(n instanceof $){if(!n.s)return void(n.o=z.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(z.bind(null,e,t),z.bind(null,e,2));e.s=t,e.v=n;const r=e.o;r&&r(e)}}const $=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(t,n){const r=new e,o=this.s;if(o){const e=1&o?t:n;if(e){try{z(r,1,e(this.v))}catch(e){z(r,2,e)}return r}return this}return this.o=function(e){try{const o=e.v;1&e.s?z(r,1,t?t(o):o):n?z(r,1,n(o)):z(r,2,o)}catch(e){z(r,2,e)}},r},e}();function L(e){return e instanceof $&&1&e.s}const _={},U={propertyTypes:[e.PropertyType.NODE,e.PropertyType.SKIN,e.PropertyType.MESH,e.PropertyType.CAMERA,e.PropertyType.PRIMITIVE,e.PropertyType.PRIMITIVE_TARGET,e.PropertyType.ANIMATION,e.PropertyType.MATERIAL,e.PropertyType.TEXTURE,e.PropertyType.ACCESSOR,e.PropertyType.BUFFER]},q=function(t=U){const n={...U,...t}.propertyTypes;return l("prune",t=>{const r=t.getLogger(),o=t.getRoot(),s=t.getGraph(),i={};if(n.includes(e.PropertyType.NODE)&&o.listNodes().forEach(a),n.includes(e.PropertyType.SKIN)&&o.listSkins().forEach(a),n.includes(e.PropertyType.MESH)&&o.listMeshes().forEach(a),n.includes(e.PropertyType.CAMERA)&&o.listCameras().forEach(a),n.includes(e.PropertyType.PRIMITIVE)&&c(s,e.PropertyType.PRIMITIVE),n.includes(e.PropertyType.PRIMITIVE_TARGET)&&c(s,e.PropertyType.PRIMITIVE_TARGET),n.includes(e.PropertyType.ANIMATION))for(const e of o.listAnimations()){for(const t of e.listChannels())t.getTargetNode()||(t.dispose(),u(t));if(e.listChannels().length)e.listSamplers().forEach(a);else{const t=e.listSamplers();a(e),t.forEach(a)}}if(n.includes(e.PropertyType.MATERIAL)&&o.listMaterials().forEach(a),n.includes(e.PropertyType.TEXTURE)&&o.listTextures().forEach(a),n.includes(e.PropertyType.ACCESSOR)&&o.listAccessors().forEach(a),n.includes(e.PropertyType.BUFFER)&&o.listBuffers().forEach(a),Object.keys(i).length){const e=Object.keys(i).map(e=>`${e} (${i[e]})`).join(", ");r.info(`prune: Removed types... ${e}`)}else r.info("prune: No unused properties found.");function a(t){t.listParents().filter(t=>!(t instanceof e.Root||t instanceof e.AnimationChannel)).length||(t.dispose(),u(t))}function c(e,t){e.listEdges().map(e=>e.getParent()).filter(e=>e.propertyType===t).forEach(a)}function u(e){i[e.propertyType]=i[e.propertyType]||0,i[e.propertyType]++}r.debug("prune: Complete.")})},F={animations:!0,meshes:!0};function k(e,t){let n=`${e}.bin`,r=1;for(;t.has(n);)n=`${e}_${r++}.bin`;return n}const G=[Int8Array,Int16Array,Int32Array],{TRANSLATION:B,ROTATION:j,SCALE:V,WEIGHTS:D}=e.AnimationChannel.TargetPath,H=[B,j,V],W={pattern:/.*/,quantizationVolume:"mesh",quantizePosition:14,quantizeNormal:10,quantizeTexcoord:12,quantizeColor:8,quantizeWeight:8,quantizeGeneric:12};function X(t,n,s,i){const a=t.getLogger();for(const t of n.listSemantics()){if(!i.pattern.test(t))continue;const c=n.getAttribute(t),{bits:u,ctor:l}=Y(t,c,a,i);if(!l)continue;if(u<8||u>16)throw new Error("quantize: Requires bits = 8–16.");if(c.getComponentSize()<=u/8)continue;const f=c.clone();if("POSITION"===t){const t=s.scale,i=[];n instanceof e.Primitive?r.invert(i,ne(s)):r.fromScaling(i,[1/t,1/t,1/t]);for(let e=0,t=[0,0,0],n=f.getCount();e<n;e++)f.getElement(e,t),f.setElement(e,o.transformMat4(t,t,i))}J(f,l,u),n.swap(c,f)}if(n.getAttribute("WEIGHTS_0")&&function(e){const t=e.getAttribute("POSITION").getCount(),n=[];for(let r=0;r<t;r++){let t,o=0,s=Infinity,i=-1,a=null,c=0;for(;t=e.getAttribute("WEIGHTS_"+c++);){t.getElement(r,n);for(let e=0;e<n.length;e++)o+=n[e],n[e]>0&&n[e]<s&&(a=t,s=n[e],i=e)}a&&1!==o&&(a.getElement(r,n),n[i]+=1-o,a.setElement(r,n))}}(n),n instanceof e.Primitive&&n.getIndices()&&n.listAttributes().length&&n.listAttributes()[0].getCount()<65535){const e=n.getIndices();e.setArray(new Uint16Array(e.getArray()))}}function K(e){const{min:t,max:n}=e,r=Math.max((n[0]-t[0])/2,(n[1]-t[1])/2,(n[2]-t[2])/2);return{offset:[t[0]+(n[0]-t[0])/2,t[1]+(n[1]-t[1])/2,t[2]+(n[2]-t[2])/2],scale:r}}function Z(t,n,o){const s=ne(o);for(const i of n.listParents())if(i instanceof e.Node){const a=i.listParents().filter(t=>t instanceof e.AnimationChannel),c=a.some(e=>H.includes(e.getTargetPath())),u=i.listChildren().length>0;if(i.getSkin()){i.setSkin(Q(i.getSkin(),o));continue}let l;u||c?(l=t.createNode("").setMesh(n),i.addChild(l).setMesh(null),a.filter(e=>e.getTargetPath()===D).forEach(e=>e.setTargetNode(l))):l=i;const f=l.getMatrix();r.multiply(f,f,s),l.setMatrix(f)}}function Q(e,t){e=e.clone();const n=ne(t),o=e.getInverseBindMatrices().clone(),s=[];for(let e=0,t=o.getCount();e<t;e++)o.getElement(e,s),r.multiply(s,s,n),o.setElement(e,s);return e.setInverseBindMatrices(o)}function J(e,t,n){const r=new t(e.getArray().length),o=G.includes(t)?1:0,s=n-o,i=8*t.BYTES_PER_ELEMENT-o,a=Math.pow(2,s)-1,c=i-s,u=2*s-i;for(let t=0,n=0,o=[];t<e.getCount();t++){e.getElement(t,o);for(let e=0;e<o.length;e++){let t=Math.round(Math.abs(o[e])*a);t=t<<c|t>>u,r[n++]=t*Math.sign(o[e])}}e.setArray(r).setNormalized(!0)}function Y(e,t,n,r){const o=t.getMinNormalized([]),s=t.getMaxNormalized([]);let i,a;if("POSITION"===e)i=r.quantizePosition,a=i<=8?Int8Array:Int16Array;else if("NORMAL"===e||"TANGENT"===e)i=r.quantizeNormal,a=i<=8?Int8Array:Int16Array;else if(e.startsWith("COLOR_"))i=r.quantizeColor,a=i<=8?Uint8Array:Uint16Array;else if(e.startsWith("TEXCOORD_")){if(o.some(e=>e<0)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [0,1] range.`),{bits:-1};i=r.quantizeTexcoord,a=i<=8?Uint8Array:Uint16Array}else{if(e.startsWith("JOINTS_"))return i=Math.max(...t.getMax([]))<=255?8:16,a=i<=8?Uint8Array:Uint16Array,t.getComponentSize()>i/8&&t.setArray(new a(t.getArray())),{bits:-1};if(e.startsWith("WEIGHTS_")){if(o.some(e=>e<0)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [0,1] range.`),{bits:-1};i=r.quantizeWeight,a=i<=8?Uint8Array:Uint16Array}else{if(!e.startsWith("_"))throw new Error(`quantize: Unexpected semantic, "${e}".`);if(o.some(e=>e<-1)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [-1,1] range.`),{bits:-1};i=r.quantizeGeneric,a=a=o.some(e=>e<0)?i<=8?Int8Array:Int16Array:i<=8?Uint8Array:Uint16Array}}return{bits:i,ctor:a}}function ee(e){const t=[],n=[];for(const r of e.listPrimitives()){const e=r.getAttribute("POSITION");e&&t.push(e);for(const e of r.listTargets()){const t=e.getAttribute("POSITION");t&&n.push(t)}}if(0===t.length)throw new Error('quantize: Missing "POSITION" attribute.');const r=te(t,3);if(n.length>0){const{min:e,max:t}=te(n,3);o.min(r.min,r.min,o.min(e,o.scale(e,e,2),[0,0,0])),o.max(r.max,r.max,o.max(t,o.scale(t,t,2),[0,0,0]))}return r}function te(e,t){const n=new Array(t).fill(Infinity),r=new Array(t).fill(-Infinity),o=[],s=[];for(const i of e){i.getMinNormalized(o),i.getMaxNormalized(s);for(let e=0;e<t;e++)n[e]=Math.min(n[e],o[e]),r[e]=Math.max(r[e],s[e])}return{min:n,max:r}}function ne(e){return r.fromRotationTranslationScale([],[0,0,0,1],e.offset,[e.scale,e.scale,e.scale])}const re={tolerance:1e-4};function oe(e,t){const n=e.getInput().clone(),r=e.getOutput().clone(),o=t.tolerance,s=n.getCount()-1,i=[];let a=1;for(let t=1;t<s;++t){const s=n.getScalar(t),u=n.getScalar(t-1),l=n.getScalar(t+1),f=(s-u)/(l-u);let g=!1;if(s!==l&&(1!==t||s!==n.getScalar(0)))for(let n=0;n<r.getElementSize();n++){const s=r.getElement(t,i)[n],a=r.getElement(t-1,i)[n],u=r.getElement(t+1,i)[n];if("LINEAR"===e.getInterpolation()){if(Math.abs(s-(a*(1-(c=f))+u*c))>o){g=!0;break}}else if("STEP"===e.getInterpolation()&&(s!==a||s!==u)){g=!0;break}}g&&(t!==a&&(n.setScalar(a,n.getScalar(t)),r.setElement(a,r.getElement(t,i))),a++)}var c;s>0&&(n.setScalar(a,n.getScalar(s)),r.setElement(a,r.getElement(s,i)),a++),a!==n.getCount()?(n.setArray(n.getArray().slice(0,a)),r.setArray(r.getArray().slice(0,a*r.getElementSize())),e.setInput(n),e.setOutput(r)):(n.dispose(),r.dispose())}const se={target:"size"};function ie(e,t,n){const r=e.getElementSize(),o=e.getCount(),s=e.getArray(),i=s.slice(0,n*r);for(let e=0;e<o;e++)for(let n=0;n<r;n++)i[t[e]*r+n]=s[e*r+n];e.setArray(i)}function ae(e){const t=[];for(const n of e.listAttributes())t.push(n);for(const n of e.listTargets())for(const e of n.listAttributes())t.push(e);return Array.from(new Set(t))}const ce={name:"",fps:10,pattern:/.*/,sort:!0},ue={overwrite:!1};function le(e){const t=e.getMaterial();if(!t)return"TEXCOORD_0";const n=t.getNormalTextureInfo();if(!n)return"TEXCOORD_0";const r=`TEXCOORD_${n.getTexCoord()}`;return e.getAttribute(r)?r:"TEXCOORD_0"}function fe(t,n,r,o,s){return t.getMode()===e.Primitive.Mode.TRIANGLES&&t.getAttribute("POSITION")&&t.getAttribute("NORMAL")&&t.getAttribute("TEXCOORD_0")?t.getAttribute("TANGENT")&&!s?(n.debug(`tangents: Skipping primitive ${o} of mesh "${r}": TANGENT found.`),!1):!t.getIndices()||(n.warn(`tangents: Skipping primitive ${o} of mesh "${r}": primitives must be unwelded.`),!1):(n.debug(`tangents: Skipping primitive ${o} of mesh "${r}": primitives must have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.`),!1)}const ge=/*#__PURE__*/"undefined"!=typeof Symbol?Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator")):"@@iterator";function pe(e,t,n){if(!e.s){if(n instanceof me){if(!n.s)return void(n.o=pe.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(pe.bind(null,e,t),pe.bind(null,e,2));e.s=t,e.v=n;const r=e.o;r&&r(e)}}const me=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(t,n){const r=new e,o=this.s;if(o){const e=1&o?t:n;if(e){try{pe(r,1,e(this.v))}catch(e){pe(r,2,e)}return r}return this}return this.o=function(e){try{const o=e.v;1&e.s?pe(r,1,t?t(o):o):n?pe(r,1,n(o)):pe(r,2,o)}catch(e){pe(r,2,e)}},r},e}();function de(e){return e instanceof me&&1&e.s}const he="textureResize";var ye;(ye=exports.TextureResizeFilter||(exports.TextureResizeFilter={})).LANCZOS3="lanczos3",ye.LANCZOS2="lanczos2";const Ae={size:[2048,2048],filter:exports.TextureResizeFilter.LANCZOS3,pattern:null},Te={};function Ee(e,t,n,r){if(r.has(e)&&r.get(e).has(t))return n.debug(`unweld: Cache hit for reused attribute, "${e.getName()}".`),r.get(e).get(t);const o=e.clone(),s=e.getArray().constructor;o.setArray(new s(t.getCount()*e.getElementSize()));const i=[];for(let n=0;n<t.getCount();n++)o.setElement(n,e.getElement(t.getScalar(n),i));return r.has(e)||r.set(e,new Map),r.get(e).set(t,o),o}const Se={tolerance:1e-4};function Ie(t,n){if(n.getIndices())return;const r=n.listAttributes()[0],o=r.getCount(),s=r.getBuffer(),i=o<=65534?new Uint16Array(3*f(n)):new Uint32Array(3*f(n)),a=t.createAccessor().setBuffer(s).setType(e.Accessor.Type.SCALAR).setArray(i);for(let e=0;e<a.getCount();e++)a.setScalar(e,e);n.setIndices(a)}function be(e,t,n){const r=Math.max(n.tolerance,Number.EPSILON),o=Math.log10(1/r),s=Math.pow(10,o),i={},a=t.getIndices(),c=a?a.getCount():t.listAttributes()[0].getCount(),u=new Map;t.listAttributes().forEach(e=>u.set(e,[])),t.listTargets().forEach(e=>{e.listAttributes().forEach(e=>u.set(e,[]))});const l=[];let f=0;for(let e=0;e<c;e++){const n=a?a.getScalar(e):e,r=[],o=[];for(const e of t.listAttributes())for(let t=0;t<e.getElementSize();t++)r.push(~~(e.getElement(n,o)[t]*s));const c=r.join("|");if(c in i)l.push(i[c]);else{for(const e of t.listAttributes())u.get(e).push(e.getElement(n,[]));for(const e of t.listTargets())for(const t of e.listAttributes())u.get(t).push(t.getElement(n,[]));i[c]=f,l.push(f),f++}}const g=t.listAttributes()[0].getCount(),p=u.get(t.getAttribute("POSITION")).length;e.getLogger().debug(`weld: ${g} → ${p} vertices.`);for(const e of t.listAttributes())Re(t,e,u.get(e)),1===e.listParents().length&&e.dispose();for(const e of t.listTargets())for(const t of e.listAttributes())Re(e,t,u.get(t)),1===t.listParents().length&&t.dispose();if(a){const e=Pe(a.getArray(),l.length);e.set(l),t.setIndices(a.clone().setArray(e)),1===a.listParents().length&&a.dispose()}else{const n=g<=65534?new Uint16Array(l):new Uint32Array(l);t.setIndices(e.createAccessor().setArray(n))}}function Pe(e,t){return new(0,e.constructor)(t)}function Re(e,t,n){const r=n.length*t.getElementSize(),o=Pe(t.getArray(),r),s=t.clone().setArray(o);for(let e=0;e<n.length;e++)s.setElement(e,n[e]);e.swap(t,s)}Object.defineProperty(exports,"bounds",{enumerable:!0,get:function(){return e.bounds}}),exports.QUANTIZE_DEFAULTS=W,exports.TEXTURE_RESIZE_DEFAULTS=Ae,exports.center=function(t=p){const n={...p,...t};return l("center",t=>{const r=t.getLogger(),o=t.getRoot(),s=o.listAnimations().length>0||o.listSkins().length>0;t.getRoot().listScenes().forEach((i,a)=>{let c;if(r.debug(`center: Scene ${a+1} / ${o.listScenes().length}.`),"string"==typeof n.pivot){const t=e.bounds(i);c=[(t.max[0]-t.min[0])/2+t.min[0],(t.max[1]-t.min[1])/2+t.min[1],(t.max[2]-t.min[2])/2+t.min[2]],"above"===n.pivot&&(c[1]=t.max[1]),"below"===n.pivot&&(c[1]=t.min[1])}else c=n.pivot;r.debug(`center: Pivot "${c.join(", ")}".`);const u=[-1*c[0],-1*c[1],-1*c[2]];if(s){r.debug("center: Model contains animation or skin. Adding a wrapper node.");const e=t.createNode("Pivot").setTranslation(u);i.listChildren().forEach(t=>e.addChild(t)),i.addChild(e)}else r.debug("center: Skipping wrapper, offsetting all root nodes."),i.listChildren().forEach(e=>{const t=e.getTranslation();e.setTranslation([t[0]+u[0],t[1]+u[1],t[2]+u[2]])})}),r.debug("center: Complete.")})},exports.colorspace=function(e){return l(m,t=>{const n=t.getLogger();if("linear"===e.inputEncoding)return void n.info(`${m}: Vertex colors already linear. Skipping conversion.`);if("sRGB"!==e.inputEncoding)return void n.error(`${m}: Unknown input encoding "${e.inputEncoding}" – should be "sRGB" or "linear". Skipping conversion.`);const r=new Set;function o(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function s(e){const t=[0,0,0];let n;for(let s=0;n=e.getAttribute(`COLOR_${s}`);s++)if(!r.has(n)){for(let e=0;e<n.getCount();e++)n.getElement(e,t),t[0]=o(t[0]),t[1]=o(t[1]),t[2]=o(t[2]),n.setElement(e,t);r.add(n)}}t.getRoot().listMeshes().forEach(e=>e.listPrimitives().forEach(s)),n.debug(`${m}: Complete.`)})},exports.dedup=h,exports.dequantize=function(e=A){const t={...A,...e};return l("dequantize",e=>{const r=e.getLogger();for(const n of e.getRoot().listMeshes())for(const e of n.listPrimitives())T(e,t);e.createExtension(n.MeshQuantization).dispose(),r.debug("dequantize: Complete.")})},exports.inspect=function(e){return{scenes:S(e),meshes:I(e),materials:b(e),textures:P(e),animations:R(e)}},exports.instance=function(t=C){return l("instance",t=>{const r=t.getLogger(),o=t.getRoot(),s=t.createExtension(n.MeshGPUInstancing);if(o.listAnimations().length)throw new Error("instance: Instancing is not currently supported for animated models.");let i=0,a=0;for(const n of o.listScenes()){const o=new Map;n.traverse(e=>{const t=e.getMesh();t&&o.set(t,(o.get(t)||new Set).add(e))});const c=[];for(const u of Array.from(o.keys())){const l=Array.from(o.get(u));if(l.length<2)continue;if(l.some(e=>e.getSkin()))continue;const f=v(t,s,u,l.length),g=f.getAttribute("TRANSLATION"),p=f.getAttribute("ROTATION"),m=f.getAttribute("SCALE"),d=t.createNode().setMesh(u).setExtension("EXT_mesh_gpu_instancing",f);n.addChild(d);let h=!1,y=!1,A=!1;for(let t=0;t<l.length;t++){let n,r,o;const s=l[t];g.setElement(t,n=s.getWorldTranslation()),p.setElement(t,r=s.getWorldRotation()),m.setElement(t,o=s.getWorldScale()),e.MathUtils.eq(n,[0,0,0])||(h=!0),e.MathUtils.eq(r,[0,0,0,1])||(y=!0),e.MathUtils.eq(o,[1,1,1])||(A=!0),s.setMesh(null),c.push(s)}h||g.dispose(),y||p.dispose(),A||m.dispose(),x(c,r),i++,a+=l.length}}i>0?r.info(`instance: Created ${i} batches, with ${a} total instances.`):(r.info("instance: No meshes with multiple parent nodes were found."),s.dispose()),r.debug("instance: Complete.")})},exports.metalRough=function(e=_){return l("metalRough",function(e){try{function t(){i.dispose();for(const e of a)e&&1===e.listParents().length&&e.dispose();r.debug("metalRough: Complete.")}const r=e.getLogger();if(!e.getRoot().listExtensionsUsed().map(e=>e.extensionName).includes("KHR_materials_pbrSpecularGlossiness"))return r.warn("metalRough: KHR_materials_pbrSpecularGlossiness not found on document."),Promise.resolve();const o=e.createExtension(n.MaterialsIOR),s=e.createExtension(n.MaterialsSpecular),i=e.createExtension(n.MaterialsPBRSpecularGlossiness),a=new Set,c=function(e,t,n){if("function"==typeof e[O]){var r,o,s,i=e[O]();if(function e(n){try{for(;!(r=i.next()).done;)if((n=t(r.value))&&n.then){if(!L(n))return void n.then(e,s||(s=z.bind(null,o=new $,2)));n=n.v}o?z(o,1,n):o=n}catch(e){z(o||(o=new $),2,e)}}(),i.return){var a=function(e){try{r.done||i.return()}catch(e){}return e};if(o&&o.then)return o.then(a,function(e){throw a(e)});a()}return o}if(!("length"in e))throw new TypeError("Object is not iterable");for(var c=[],u=0;u<e.length;u++)c.push(e[u]);return function(e,t,n){var r,o,s=-1;return function n(i){try{for(;++s<e.length;)if((i=t(s))&&i.then){if(!L(i))return void i.then(n,o||(o=z.bind(null,r=new $,2)));i=i.v}r?z(r,1,i):r=i}catch(e){z(r||(r=new $),2,e)}}(),r}(c,function(e){return t(c[e])})}(e.getRoot().listMaterials(),function(t){function n(){t.setExtension("KHR_materials_pbrSpecularGlossiness",null)}const r=t.getExtension("KHR_materials_pbrSpecularGlossiness");if(!r)return;const i=s.createSpecular().setSpecularFactor(1).setSpecularColorFactor(r.getSpecularFactor());a.add(r.getSpecularGlossinessTexture()),a.add(t.getBaseColorTexture()),a.add(t.getMetallicRoughnessTexture()),t.setBaseColorFactor(r.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension("KHR_materials_ior",o.createIOR().setIOR(1e3)).setExtension("KHR_materials_specular",i);const c=r.getDiffuseTexture();c&&(t.setBaseColorTexture(c),t.getBaseColorTextureInfo().copy(r.getDiffuseTextureInfo()));const l=r.getSpecularGlossinessTexture(),f=function(){if(l){const n=r.getSpecularGlossinessTextureInfo(),o=e.createTexture();return Promise.resolve(u(l,o,(e,t,n)=>{e.set(t,n,3,255)})).then(function(){i.setSpecularTexture(o),i.setSpecularColorTexture(o),i.getSpecularTextureInfo().copy(n),i.getSpecularColorTextureInfo().copy(n);const s=r.getGlossinessFactor(),a=e.createTexture();return Promise.resolve(u(l,a,(e,t,n)=>{const r=255-Math.round(e.get(t,n,3)*s);e.set(t,n,0,0),e.set(t,n,1,r),e.set(t,n,2,0),e.set(t,n,3,255)})).then(function(){t.setMetallicRoughnessTexture(a),t.getMetallicRoughnessTextureInfo().copy(n)})})}i.setSpecularColorFactor(r.getSpecularFactor()),t.setRoughnessFactor(1-r.getGlossinessFactor())}();return f&&f.then?f.then(n):n()});return Promise.resolve(c&&c.then?c.then(t):t())}catch(e){return Promise.reject(e)}})},exports.partition=(t=F)=>{const n={...F,...t};return l("partition",function(t){try{const r=t.getLogger();return!1!==n.meshes&&function(e,t,n){const r=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listMeshes().forEach((o,s)=>{if(Array.isArray(n.meshes)&&!n.meshes.includes(o.getName()))return void t.debug(`partition: Skipping mesh #${s} with name "${o.getName()}".`);t.debug(`partition: Creating buffer for mesh "${o.getName()}".`);const i=e.createBuffer(o.getName()).setURI(k(o.getName()||"mesh",r));o.listPrimitives().forEach(e=>{const t=e.getIndices();t&&t.setBuffer(i),e.listAttributes().forEach(e=>e.setBuffer(i)),e.listTargets().forEach(e=>{e.listAttributes().forEach(e=>e.setBuffer(i))})})})}(t,r,n),!1!==n.animations&&function(e,t,n){const r=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listAnimations().forEach((o,s)=>{if(Array.isArray(n.animations)&&!n.animations.includes(o.getName()))return void t.debug(`partition: Skipping animation #${s} with name "${o.getName()}".`);t.debug(`partition: Creating buffer for animation "${o.getName()}".`);const i=e.createBuffer(o.getName()).setURI(k(o.getName()||"animation",r));o.listSamplers().forEach(e=>{const t=e.getInput(),n=e.getOutput();t&&t.setBuffer(i),n&&n.setBuffer(i)})})}(t,r,n),n.meshes||n.animations||r.warn("partition: Select animations or meshes to create a partition."),Promise.resolve(t.transform(q({propertyTypes:[e.PropertyType.BUFFER]}))).then(function(){r.debug("partition: Complete.")})}catch(e){return Promise.reject(e)}})},exports.prune=q,exports.quantize=(t=W)=>{const r={...W,...t};return l("quantize",function(t){try{const s=t.getLogger(),i=t.getRoot();let a;t.createExtension(n.MeshQuantization).setRequired(!0),"scene"===r.quantizationVolume&&(a=K(function(e){const t=e[0];for(const n of e)o.min(t.min,t.min,n.min),o.max(t.max,t.max,n.max);return t}(i.listMeshes().map(ee))));for(const e of t.getRoot().listMeshes()){"mesh"===r.quantizationVolume&&(a=K(ee(e))),a&&r.pattern.test("POSITION")&&Z(t,e,a);for(const n of e.listPrimitives()){X(t,n,a,r);for(const e of n.listTargets())X(t,e,a,r)}}return Promise.resolve(t.transform(q({propertyTypes:[e.PropertyType.ACCESSOR,e.PropertyType.SKIN]}),h({propertyTypes:[e.PropertyType.ACCESSOR]}))).then(function(){s.debug("quantize: Complete.")})}catch(e){return Promise.reject(e)}})},exports.reorder=function(t=se){const n={...se,...t},r=n.encoder;return l("reorder",function(t){try{const o=t.getLogger();return Promise.resolve(r.ready).then(function(){const s=function(e){const t=new g,n=new Map,r=new g;for(const o of e.getRoot().listMeshes())for(const e of o.listPrimitives()){const o=e.getIndices();if(o){n.set(o,e.getMode());for(const n of ae(e))t.add(o,n),r.add(n,e)}}return{indicesToAttributes:t,indicesToMode:n,attributesToPrimitives:r}}(t);for(const t of s.indicesToAttributes.keys()){const o=t.clone();let i=o.getArray().slice();i instanceof Uint32Array||(i=new Uint32Array(i));const[a,c]=r.reorderMesh(i,s.indicesToMode.get(t)===e.Primitive.Mode.TRIANGLES,"size"===n.target);o.setArray(c<=65534?new Uint16Array(i):i);for(const e of s.indicesToAttributes.get(t)){const n=e.clone();ie(n,a,c);for(const r of s.attributesToPrimitives.get(e))if(r.getIndices()===t&&r.swap(t,o),r.getIndices()===o){r.swap(e,n);for(const t of r.listTargets())t.swap(e,n)}}}return Promise.resolve(t.transform(q({propertyTypes:[e.PropertyType.ACCESSOR]}))).then(function(){s.indicesToAttributes.size?o.debug("reorder: Complete."):o.warn("reorder: No qualifying primitives found; may need to weld first.")})})}catch(e){return Promise.reject(e)}})},exports.resample=(t=re)=>{const n={...re,...t};return l("resample",(t,r)=>{const o=new Set,s=t.getRoot().listAccessors().length,i=t.getLogger();let a=!1;for(const e of t.getRoot().listAnimations()){const t=new Set;for(const n of e.listChannels())n.getSampler()&&"weights"===n.getTargetPath()&&t.add(n.getSampler());for(const r of e.listSamplers())t.has(r)?a=!0:"STEP"!==r.getInterpolation()&&"LINEAR"!==r.getInterpolation()||(o.add(r.getInput()),o.add(r.getOutput()),oe(r,n))}for(const t of Array.from(o.values()))t.listParents().some(t=>!(t instanceof e.Root))||t.dispose();t.getRoot().listAccessors().length>s&&!function(e,t,n){return!!e&&e.stack.lastIndexOf("resample")<e.stack.lastIndexOf("dedup")}(r)&&i.warn('resample: Resampling required copying accessors, some of which may be duplicates. Consider using "dedup" to consolidate any duplicates.'),a&&i.warn("resample: Skipped optimizing morph target keyframes, not yet supported."),i.debug("resample: Complete.")})},exports.sequence=function(t=ce){const n={...ce,...t};return l("sequence",t=>{const r=t.getLogger(),o=t.getRoot(),s=n.fps,i=o.listNodes().filter(e=>e.getName().match(n.pattern));n.sort&&i.sort((e,t)=>e.getName()>t.getName()?1:-1);const a=t.createAnimation(n.name),c=o.listBuffers()[0];i.forEach((n,r)=>{let o,u;0===r?(o=[r/s,(r+1)/s],u=[1,1,1,0,0,0]):r===i.length-1?(o=[(r-1)/s,r/s],u=[0,0,0,1,1,1]):(o=[(r-1)/s,r/s,(r+1)/s],u=[0,0,0,1,1,1,0,0,0]);const l=t.createAccessor().setArray(new Float32Array(o)).setBuffer(c),f=t.createAccessor().setArray(new Float32Array(u)).setBuffer(c).setType(e.Accessor.Type.VEC3),g=t.createAnimationSampler().setInterpolation(e.AnimationSampler.Interpolation.STEP).setInput(l).setOutput(f),p=t.createAnimationChannel().setTargetNode(n).setTargetPath(e.AnimationChannel.TargetPath.SCALE).setSampler(g);a.addSampler(g).addChannel(p)}),r.debug("sequence: Complete.")})},exports.tangents=function(t=ue){if(!t.generateTangents)throw new Error('tangents: generateTangents callback required — install "mikktspace".');const n={...ue,...t};return l("tangents",t=>{const r=t.getLogger(),o=new Map,s=new Map;let i=0;for(const a of t.getRoot().listMeshes()){const c=a.getName(),u=a.listPrimitives();for(let a=0;a<u.length;a++){const l=u[a];if(!fe(l,r,c,a,n.overwrite))continue;const f=le(l),g=l.getAttribute("POSITION").getArray(),p=l.getAttribute("NORMAL").getArray(),m=l.getAttribute(f).getArray(),d=o.get(g)||e.uuid();o.set(g,d);const h=o.get(p)||e.uuid();o.set(p,h);const y=o.get(m)||e.uuid();o.set(m,y);const A=l.getAttribute("TANGENT");A&&2===A.listParents().length&&A.dispose();const T=`${d}|${h}|${y}`;let E=s.get(T);if(E){r.debug(`tangents: Found cache for primitive ${a} of mesh "${c}".`),l.setAttribute("TANGENT",E),i++;continue}r.debug(`tangents: Generating for primitive ${a} of mesh "${c}".`);const S=l.getAttribute("POSITION").getBuffer(),I=n.generateTangents(g instanceof Float32Array?g:new Float32Array(g),p instanceof Float32Array?p:new Float32Array(p),m instanceof Float32Array?m:new Float32Array(m));for(let e=3;e<I.length;e+=4)I[e]*=-1;E=t.createAccessor().setBuffer(S).setArray(I).setType("VEC4"),l.setAttribute("TANGENT",E),s.set(T,E),i++}}i?r.debug("tangents: Complete."):r.warn("tangents: No qualifying primitives found. See debug output.")})},exports.textureResize=function(e=Ae){const n={...Ae,...e};return l(he,function(e){try{let o;function r(e){s.debug(`${he}: Complete.`)}const s=e.getLogger(),a=function(e,t,n){if("function"==typeof e[ge]){var r,o,s,i=e[ge]();if(function e(a){try{for(;!((r=i.next()).done||n&&n());)if((a=t(r.value))&&a.then){if(!de(a))return void a.then(e,s||(s=pe.bind(null,o=new me,2)));a=a.v}o?pe(o,1,a):o=a}catch(e){pe(o||(o=new me),2,e)}}(),i.return){var a=function(e){try{r.done||i.return()}catch(e){}return e};if(o&&o.then)return o.then(a,function(e){throw a(e)});a()}return o}if(!("length"in e))throw new TypeError("Object is not iterable");for(var c=[],u=0;u<e.length;u++)c.push(e[u]);return function(e,t,n){var r,o,s=-1;return function i(a){try{for(;++s<e.length&&(!n||!n());)if((a=t(s))&&a.then){if(!de(a))return void a.then(i,o||(o=pe.bind(null,r=new me,2)));a=a.v}r?pe(r,1,a):r=a}catch(e){pe(r||(r=new me),2,e)}}(),r}(c,function(e){return t(c[e])},n)}(e.getRoot().listTextures(),function(e){const r=e.getName(),o=e.getURI();if(n.pattern&&!n.pattern.test(r)&&!n.pattern.test(o))return;if("image/png"!==e.getMimeType()&&"image/jpeg"!==e.getMimeType())return void s.warn(`Skipping unsupported texture type, "${e.getMimeType()}".`);const[a,u]=n.size,[l,f]=e.getSize();if(l<=a&&f<=u)return void s.debug(`${he}: Skipping "${o||r}", within size range.`);let g=l,p=f;g>a&&(p=Math.floor(p*(a/g)),g=a),p>u&&(g=Math.floor(g*(u/p)),p=u);const m=e.getImage();return Promise.resolve(t.getPixels(m,e.getMimeType())).then(function(a){const u=c.default(new Uint8Array(g*p*4),[g,p,4]);s.debug(`${he}: Resizing "${o||r}", ${a.shape} → ${u.shape}...`);try{n.filter===exports.TextureResizeFilter.LANCZOS3?i.lanczos3(a,u):i.lanczos2(a,u)}catch(e){if(e instanceof Error)return void s.warn(`${he}: Failed to resize "${o||r}": "${e.message}".`);throw e}const l=e.setImage;return Promise.resolve(t.savePixels(u,e.getMimeType())).then(function(t){l.call(e,t)})})},function(){return o});return Promise.resolve(a&&a.then?a.then(r):r())}catch(e){return Promise.reject(e)}})},exports.unweld=function(e=Te){return l("unweld",e=>{const t=e.getLogger(),n=new Map;for(const r of e.getRoot().listMeshes())for(const e of r.listPrimitives()){const r=e.getIndices();if(r){for(const o of e.listAttributes())e.swap(o,Ee(o,r,t,n)),1===o.listParents().length&&o.dispose();for(const o of e.listTargets())for(const e of o.listAttributes())o.swap(e,Ee(e,r,t,n)),1===e.listParents().length&&e.dispose();e.setIndices(null),1===r.listParents().length&&r.dispose()}}t.debug("unweld: Complete.")})},exports.weld=function(e=Se){const t={...Se,...e};return l("weld",e=>{const n=e.getLogger();for(const n of e.getRoot().listMeshes())for(const r of n.listPrimitives())0===t.tolerance?Ie(e,r):be(e,r,t);n.debug("weld: Complete.")})};
//# sourceMappingURL=functions.js.map
